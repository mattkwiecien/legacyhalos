#!/usr/bin/env python
"""Generate the figures for the SGA 2020 paper.

Load the legacyhalos code product, then, e.g.:
SGA-2020-figures --surface-brightness --sbmontage-gallery
etc.

"""
import os, sys, time, pdb
import argparse, subprocess
import numpy as np
import fitsio

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from astropy.table import Table, vstack, join

import legacyhalos.SGA
from legacyhalos.SGA import get_galaxy_galaxydir
from legacyhalos.SGA import DIAMCOLUMN, RACOLUMN, DECCOLUMN

paperdir = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'science', 'SGA-2020-paper')
figdir = os.path.join(paperdir, 'figures')
tabledir = os.path.join(paperdir, 'tables')

#figdir = os.path.join('/mnt', 'SGA', 'science', 'paper1', 'figures')
#figdir = os.path.join('/mnt', '20210115-aas-sga')
#figdir = os.path.join(os.getenv('HOME'), 'research', 'talks', '2021', '20210115-aas-sga')
#if not os.path.isdir(figdir):
#    figdir = os.path.join(os.getenv('HOME'), 'SGA', 'science', 'paper1', 'figures')
#    #figdir = os.path.join(os.getenv('HOME'), 'SGA', 'science', 'paper1', 'figures')
fonttype = os.path.join(os.getenv('LEGACYHALOS_CODE_DIR'), 'py', 'legacyhalos', 'data', 'Georgia-Italic.ttf')

url = 'https://portal.nersc.gov/project/cosmo/data/sga/2020/data/'
jpgurl = 'https://www.legacysurvey.org/viewer/jpeg-cutout?'

#os.environ['LEGACYHALOS_DIR'] = os.path.join(os.getenv('HOME'), 'research', 'projects', 'SGA')
#os.environ['LEGACYHALOS_DATA_DIR'] = figdir

def plot_style(font_scale=1.2, paper=False, talk=True):

    import seaborn as sns
    rc = {'font.family': 'serif'}#, 'text.usetex': True}
    #rc = {'font.family': 'serif', 'text.usetex': True,
    #       'text.latex.preamble': r'\boldmath'})
    palette, context = 'Set2', 'talk'
    
    if paper:
        context = 'paper'
        palette = 'deep'
        rc.update({'text.usetex': False})
    
    if talk:
        context = 'talk'
        palette = 'deep'
        #rc.update({'text.usetex': True})

    sns.set(context=context, style='ticks', font_scale=font_scale, rc=rc)
    sns.set_palette(palette, 12)

    colors = sns.color_palette()
    #sns.reset_orig()

    return sns, colors

def table_dwarfs(tex=None):

    dwarfsfile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'SGA-dwarfs.fits')
    dwarfs = Table(fitsio.read(dwarfsfile, upper=True))
    print('Read {} Local Group dwarfs from {}'.format(len(dwarfs), dwarfsfile))

    I = dwarfs['IGNORE']
    ignore = ', '.join(np.sort(dwarfs[I]['GALAXY'].data))
    ignore = ignore.replace('aI', 'a I').replace('aV', 'a V')
    ignore = ignore.replace('aX', 'a X').replace('sI', 's I').replace('ciI', 'ci I').replace('sV', 's V')
    ignore = ignore.replace('aB', 'a B').replace('oI', 'o I').replace('oT', 'o T').replace('oV', 'o V')
    ignore = ignore.replace('sdS', 's dS').replace('eI', 'e I').replace('aM', 'a M').replace('rI', 'r I').replace('n1', 'n 1')
    print()
    print('Ignore {} faint galaxies: {}'.format(np.sum(I), ignore))
    print('Min, max, median SB: {:.3f}, {:.3f}, {:.3f}'.format(
        np.min(dwarfs[I]['SB_D25']), np.max(dwarfs[I]['SB_D25']), 
        np.median(dwarfs[I]['SB_D25'])))

    J = dwarfs['RESOLVED']
    print()
    print('Ignore {} resolved galaxies: {}'.format(np.sum(J), ', '.join(np.sort(dwarfs[J]['GALAXY'].data))))

    #if tex:
    #    texfile = os.path.join(tabledir, tex)
    #    print('Writing {}'.format(texfile))
    #
    #    with open(texfile, 'w') as F:
    #        F.write('\begin{deluxetable}{ccccccc}[!h]\n')
    #        F.write('\tablecaption{Milky Way Dwarf Galaxies\label{table:dwarfs}}\n')
    #        F.write('\tablewidth{0pt}\n')
    #        F.write('\tablehead{\n')
    #        F.write('\colhead{} & \n')
    #        F.write('\colhead{} & \n')
    #        F.write('\colhead{$\mathbf{\lambda_{\rm eff}}$} & \n')
    #        F.write('\colhead{Area} & \n')
    #        F.write('\colhead{Depth} & \n')
    #        F.write('\colhead{Pixel Scale\tablenotemark{a}} & \n')
    #        F.write('\colhead{Image Quality} \\\n')
    #        F.write('\colhead{Survey} & \n')
    #        F.write('\colhead{Band} & \n')
    #        F.write('\colhead{($\micron$)} &\n')
    #        F.write('\colhead{(deg$^{2}$)} & \n')
    #        F.write('\colhead{(AB mag, $5\sigma$ PSF)} & \n')
    #        F.write('\colhead{(arcsec)} & \n')
    #        F.write('\colhead{(FWHM, arcsec)}\n')
    #        F.write('}\n')
    #        F.write('\startdata\n')
    #        F.write('\textit{WISE} & W4 & 22 & All-sky & 10.6 & 2.75 & 12 \\\n')
    #        F.write('\enddata\n')
    #        F.write('\tablenotetext{a}{Pixel scale of the image stacks generated as part of the \shortatlas; see \S\ref{sec:mosaics}.}\n')
    #        F.write('\end{deluxetable}\n')

def fig_sample_montage(sample, seed=1, png=None):
    """Show a random sampling of galaxies.

    """
    from legacyhalos.qa import addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'montage-galaxies')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    rand = np.random.RandomState(seed=seed)

    ncol = 7
    nrow = 6
    ngal = ncol * nrow

    # Pick XX random galaxies, uniformly selected in surface brightness.
    #r50 = tractor['SHAPE_R'].data
    #rmag = 22.5-2.5*np.log10(tractor['FLUX_R'].data)
    #sb = rmag + 2.5 * np.log10(np.pi * (60/2)**2) + 5*np.log10(r50/60)

    if False:
        good = np.where((sample['SMA_SB26'] != -1) * (sample['R_MAG_SB26'] != -1) * (sample['DEC'] < 30))[0]
        sample = sample[good]
    
        rmag = sample['R_MAG_SB26'].data
        r50 = sample['SMA_SB26'].data # [arcsec]
        sb = rmag + 2.5 * np.log10(2 * np.pi * r50**2)
        sample['SB'] = sb
    
        keep = np.where((rmag < 19) * (rmag > 13) * (r50 > 20) * (sb < 25) * (sb > 22))[0]
        print(len(keep))
        sample = sample[keep]
        print(np.min(sample['SB']), np.max(sample['SB']))

        nbin = 20
        _xbin = np.linspace(np.min(sample['SB']), np.max(sample['SB']), nbin)
        idx  = np.digitize(sample['SB'], _xbin)
    else:
        good = np.where((sample['GROUP_MULT'] == 1) * (sample['DEC'] < 30) *
                        (sample['SMA_SB26'] > 60) * (sample['SMA_SB26'] < 300) * # 1-10 arcmin
                        (sample['R_MAG_SB26'] > 12) * (sample['R_MAG_SB26'] < 20))[0]
        sample = sample[good]

        nbin = 10
        _xbin = np.linspace(np.min(sample['SMA_SB26']), np.max(sample['SMA_SB26']), nbin)
        idx  = np.digitize(sample['SMA_SB26'], _xbin)
        #_xbin = np.linspace(np.min(sample['GROUP_DIAMETER']), np.max(sample['GROUP_DIAMETER']), nbin)
        #idx  = np.digitize(sample['GROUP_DIAMETER'], _xbin)

    prob = np.zeros(len(sample))
    for kk in range(nbin):
        ww = idx == kk
        if np.sum(ww) > 0:
            prob[ww] = 1 / np.sum(ww)
    prob /= np.sum(prob)

    these = rand.choice(len(sample), ngal, p=prob, replace=False)
    #if seed == 5:
    #    these[8] = these[8] + 1 # SDSSJ222743.82+070833.3 is Galactic cirrus

    if False:
        srt = np.argsort(sample['SB'][these])
    else:
        srt = np.argsort(sample['SMA_SB26'][these])

    sample = sample[these[srt]]
    #print(sb.data)
    
    #print(sample['GALAXY', 'SMA_SB26', 'R_MAG_SB26', 'SB', 'GROUP_DIAMETER'])
    print(sample['GROUP_NAME', 'GROUP_DIAMETER', 'GROUP_MULT', 'SMA_SB26', 'R_MAG_SB26'])

    pixscale = 0.262
    barlen = np.ceil(60 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    gal, galdir = get_galaxy_galaxydir(sample)
    pngfiles = []
    for onegal, gal1, galdir1 in zip(sample, gal, galdir):
        jpgfile = os.path.join(galdir1, f'{gal1}-largegalaxy-image-grz.jpg')
        if not os.path.isfile(jpgfile):
            urlfile = url+'/'.join(jpgfile.split('/')[-3:])
            jpgfile = os.path.join(montagedir, f'{gal1}-largegalaxy-image-grz.jpg')
            if not os.path.isfile(jpgfile):
                cmd = f'wget -q -O {jpgfile} {urlfile}'
                print(cmd)
                subprocess.call(cmd.split())

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            addbar_to_png(jpgfile, barlen, barlabel, gal1.replace('_GROUP', ' Group'), pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        #cmd = 'montage -tile {}x{} -geometry 128x128 '.format(ncol, nrow)
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_hyperleda_rejects(sga, png=None):
    """Assortment of Hyperleda junk rejected by visual inspection."""

    from PIL import Image
    from SGA.io import read_hyperleda
    import astropy.units as u
    from astropy.io import fits
    from astropy.wcs import WCS
    from astropy.coordinates import SkyCoord
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'hyperleda-rejects')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 0.262
    barlen = np.ceil(30 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 4
    nrow = 3
    ngal = ncol * nrow

    os.environ['SGA_DIR'] = os.getenv('LEGACYHALOS_DIR')
    sample = read_hyperleda()
    #samplefile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'hyperleda', 'hyperleda-d25min10-18nov14.fits')
    #sample = Table(fitsio.read(samplefile, columns=['galaxy', 'pgc', 'ra', 'dec', 'pa', 'ba', 'd25', 'diam_ref'], upper=True))

    rejfile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'leda-spurious.txt')
    print(rejfile)
    #rejgal = np.loadtxt(rejfile, dtype=str)
    rejgal, reason = [], []
    with open(rejfile, 'r') as F:
        for line in F:
            words = line.split(' ')
            if words[0] == '#':
                continue
            rejgal.append(words[0].replace('\n', ''))
            if 'pre-fitting (' in line:
                words = words[:np.where(np.isin(words, 'pre-fitting'))[0][0]+1]
            if len(words) > 1 and words[1] != '':
                _reason = ' '.join(words[1:]).replace('\n', '')
                if 'HII' in _reason:
                    _reason = 'HII region'
                elif 'PoG' in _reason:
                    _reason = 'PoG'
                elif 'wrong diameter' in _reason:
                    _reason = 'wrong diameter'
                elif _reason == '':
                    _reason = 'none'
            else:
                _reason = 'none'
            _reason = _reason.strip()
            #if _reason == '':
            #    pdb.set_trace()
            reason.append(_reason)

    allrej = Table()
    allrej['GALAXY'] = rejgal
    allrej['REASON'] = reason

    _, U = np.unique(allrej['GALAXY'], return_index=True)
    allrej = allrej[U]

    # rejected galaxies not in Hyperleda
    I = ~np.isin(allrej['GALAXY'], sample['GALAXY'].data)
    extrarej = allrej[I]
    nodr8 = ['DR8' not in gal for gal in extrarej['GALAXY']]
    #print(extrarej[nodr8])

    #allreasons = rej['reason'].data
    #for reason in np.unique(rej['reason']):
    hyperrej = join(sample['GALAXY', 'RA', 'DEC', 'D25', 'BA', 'PA'], allrej, keys='GALAXY')

    _, U = np.unique(hyperrej['REASON'], return_index=True)
    hyperrej[U]['GALAXY', 'D25', 'REASON'].write('junk.txt', format='ascii.fast_tab', overwrite=True)

    #print(hyperrej[U][hyperrej[U]['D25'] > 0.5])

    #'IC2144', # reflection nebula - not in Hyperleda
    #'PGC061664', # way overestimated diameter (star+merger)

    I = hyperrej['D25'] > 1
    J = ['wrong diameter' in reason for reason in hyperrej['REASON'][I]]
    print(hyperrej[I][J])

    rejgal = [
        'PGC095115', # spurious
        'PGC1373079', # spurious (pair of stars)
        'PGC1192899', # two stars        
        'PGC1497763', # trio of stars
        #'PGC1231967', # trio of stars
        'SDSSJ020334.60-092540.0', # spurious / wrong diameter
        'PGC460281', # star / wrong diameter
        'PGC1453208', # trio of stars near medium star
        'PGC2500856', # star between two real galaxies
        #'PGC039027', # LSB?
        'PGC1111201', # PofG / part of PGC1111317
        'PGC071502', # spurious / part of ESO240-004
        'PGC093084', # HII region in NGC1507
        #'PGC129468', # duplicate"
        #'PGC432973', # duplicate / shred of PGC432946"
        'SDSSJ211630.38+001817.7', # shredded with PGC188224
    ]

    #rejgal = [
    #    'PGC1288721',   # wrong diameter (trio of galaxies)
    #    'PGC166101',    # totally spurious (and >2 arcmin!)
    #    'PGC3112871',   # wrong diameter (impacted by nearby star)
    #    'PGC3097828',   # spurious (reflection from a nearby star?)        
    #    'PGC1189991',   # spurious (triple of stars)
    #    #'PGC2133030',   # spurious (triple of stars)
    #    'PGC051602',    # REX   over-estimated diameter in Hyperleda
    #]

    # retain the order
    I = np.hstack([np.where(hyperrej['GALAXY'] == gal)[0] for gal in rejgal])
    #I = np.isin(hyperrej['GALAXY'], rejgal)

    samp = hyperrej[I]
    print(samp)

    # find the SGA sources near these rejects
    coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    coord_samp = SkyCoord(ra=samp['RA']*u.deg, dec=samp['DEC']*u.deg)

    sga_close = []
    for coord_samp1, d25 in zip(coord_samp, samp['D25']):
        sep = coord_samp1.separation(coord_sga)
        close = sep.arcsec < 2*d25*60
        if np.any(close):
            sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
        else:
            sga_close.append(Table())

    pngfiles = []
    for onegal, onesga in zip(samp, sga_close):
        jpgfile = os.path.join(montagedir, '{}-reject.jpg'.format(onegal['GALAXY']))
        width = int(2 * onegal['D25'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['RA'], onegal['DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = onegal['RA']
        hdr['CRVAL2'] = onegal['DEC']
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600
        wcs = WCS(hdr)

        if width > 500:
            lw = 4
        else:
            lw = 2
        print(onegal['GALAXY'], width, lw)

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size
                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                                    onegal['PA'], onegal['D25'] * 60.0, pixscale, 
                                    color='tomato', linewidth=lw)
                # add the SGA sources, if any
                if len(onesga) > 0:
                    for onesga1 in onesga:
                        xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                        draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                            onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                            color='dodgerblue', linewidth=lw)
                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            addbar_to_png(pngfile1, barlen, barlabel, onegal['GALAXY'], pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_sky(S, png=None):

    import seaborn as sns
    import healpy as hp
    from astropy.coordinates import SkyCoord
    from astropy import units, constants
    from desiutil.plots import init_sky, prepare_data, plot_sky_binned

    #sns, _ = plot_style(talk=True, font_scale=0.8)

    font = {'size': 14,} #'family': 'normal', 'weight': 'bold'}
    mpl.rc('font', **font)

    # AR DES
    def plot_des(ax, desfn=None, **kwargs):
        if desfn is None:
            desfn = os.path.join(os.getenv("DESI_ROOT"), "survey", "observations", "misc", "des_footprint.txt")
        ras, decs = np.loadtxt(desfn, unpack=True)
        ax.plot(ax.projection_ra(ras), ax.projection_dec(decs), **kwargs)
            
    # AR galactic, ecliptic plane
    def plot_gp_ep(ax, frame, npt=1000, **kwargs):
        """
        frame: "galactic" or "barycentricmeanecliptic"

        """ 
        cs =  SkyCoord(
            np.linspace(0, 360, npt) * units.degree,
            np.zeros(npt) * units.degree,
            frame=frame,
        )       
        ras, decs = cs.icrs.ra.degree, cs.icrs.dec.degree
        ii = ax.projection_ra(ras).argsort()
        _ = ax.plot(ax.projection_ra(ras[ii]), ax.projection_dec(decs[ii]), **kwargs)
    
    def custom_plot_sky_circles(ax, ra_center, dec_center, field_of_view, **kwargs):
        """
        similar to desiutil.plots.plot_sky_circles
        but with propagating **kwargs
        """
        if (isinstance(ra_center, int) | isinstance(ra_center, float)):
            ra_center, dec_center = np.array([ra_center]), np.array([dec_center])
        proj_edge = ax._ra_center - 180
        while proj_edge < 0:
            proj_edge += 360
        #
        angs = np.linspace(2 * np.pi, 0, 101)
        for ra, dec in zip(ra_center, dec_center):
            ras = ra + 0.5 * field_of_view / np.cos(np.radians(dec)) * np.cos(angs)
            decs = dec + 0.5 * field_of_view * np.sin(angs)
            for sel in [ras > proj_edge, ras <= proj_edge]:
                if sel.sum() > 0:
                    ax.fill(ax.projection_ra(ras[sel]), ax.projection_dec(decs[sel]), **kwargs)
    
    # adapted from https://github.com/desihub/desiutil/blob/5735fdc34c4e77c7fda84c92c32b9ac41158b8e1/py/desiutil/plots.py#L735-L857
    def ar_sky_cbar(ax, sc, label, extend=None, mloc=None):
        cbar = plt.colorbar(sc, ax=ax, location='bottom',
                            orientation="horizontal",
                            spacing="proportional",
                            extend=extend, extendfrac=0.025,
                            #pad=0.1, 
                            fraction=0.035, aspect=40)
        cbar.ax.xaxis.set_ticks_position("bottom")
        cbar.set_label(label)#, labelpad=10)
        if mloc is not None:
            cbar.ax.xaxis.set_major_locator(ticker.MultipleLocator(mloc))

    ras = S['RA'].data
    decs = S['DEC'].data
    cmap = 'Blues' # 'vlag'
    cmap = sns.color_palette(cmap, as_cmap=True)

    ## Make zero values truly white (cmap.Blue(0) = 0.97,0.98,1.0)
    #cmap = mpl.colormaps.get_cmap(cmap).copy()
    #cmap.set_bad(color='white')
    #cmap.set_under(color='white')
    #cmap.set_over(color='white')

    #nside = 16
    #nest = True
    #
    #bin_area = hp.nside2pixarea(nside, degrees=True)
    #print(bin_area)
    #
    #npix = hp.nside2npix(nside)
    #pixels = hp.ang2pix(nside, np.radians(90 - decs), np.radians(ras), nest=nest)
    #counts = np.bincount(pixels, weights=np.ones_like(ras), minlength=npix)
    #
    #grid_data = counts / bin_area
    #grid_data = prepare_data(grid_data, clip_lo=None, clip_hi=None)
    #
    ##cs = np.random.uniform(size=len(S))
    #sc = ax.scatter(ax.projection_ra(ras), ax.projection_dec(decs), s=1)#, c=cs)
    
    fig = plt.figure(figsize=(10, 7), dpi=300)
    ax = fig.add_subplot(111, projection='mollweide')

    ax = init_sky(galactic_plane_color='gray', ecliptic_plane_color='none', ax=ax)

    ax, data = plot_sky_binned(ras, decs, plot_type='healpix', max_bin_area=10, 
                               clip_lo=0, clip_hi='99%', verbose=True, ax=ax, 
                               cmap=cmap, return_grid_data=True, colorbar=False)
    ax.set_ylabel('Dec (degrees)')
    ax.set_xlabel('RA (degrees)')

    sc = ax.collections[2]
    
    ar_sky_cbar(ax, sc, r'Galaxy Surface Density (deg$^{-2}$)', extend='both', mloc=10)

    # AR DES, galactic, ecliptic plane
    #desfn = os.path.join(os.getenv("DESI_ROOT"), "survey", "observations", "misc", "des_footprint.txt")
    #plot_des(ax, desfn=desfn, c="orange", lw=0.5, alpha=1, zorder=1)
    #plot_gp_ep(ax, "galactic", c="k", lw=1, alpha=1, zorder=1)
    #plot_gp_ep(ax, "barycentricmeanecliptic", c="k", lw=0.25, alpha=1, ls="--", zorder=1)

    ## AR circle
    #custom_plot_sky_circles(ax, 0, 0, 2 * 20, color="g", facecolor="none")
    #custom_plot_sky_circles(ax, 290, 0, 2 * 20, color="b", alpha=0.5)
    
    #ax.set_axisbelow(True)

    fig.subplots_adjust(left=0.1, bottom=0.13, right=0.95, top=0.95)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)
        plt.close(fig)            

def fig_sky2(S, png=None):

    import copy
    from astrometry.util.util import anwcs_create_hammer_aitoff
    from astrometry.util.starutil_numpy import lbtoradec
    import matplotlib.cm as cm
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    sns, _ = plot_style(talk=True, font_scale=0.8)

    print(len(S))

    # initialize the projection
    zoom = 1
    W,H = 800,400
    #W,H = 1000,500
    #W,H = 2000,1000
    ra_center = 120. # 275.
    wcs = anwcs_create_hammer_aitoff(ra_center, 0., zoom, W, H, False)
    ok,S.x,S.y = wcs.radec2pixelxy(S['RA'], S['DEC'])

    sgacount = np.zeros(wcs.shape, np.int16)
    np.add.at(sgacount, (S.y.astype(int), S.x.astype(int)), 1)
    x,y = W//2, H//2
    ok,rr,dd = wcs.pixelxy2radec([x, x+1, x], [y, y, y+1])
    cosdec = np.cos(np.deg2rad(dd[0]))
    dr1 = (rr[1]-rr[0])*cosdec
    dd1 = dd[1]-dd[0]
    dr2 = (rr[2]-rr[0])*cosdec
    dd2 = dd[2]-dd[0]
    pixelarea = np.hypot(dr1,dd1) * np.hypot(dr2,dd2)

    # build the figure
    fig = plt.figure(figsize=(12,8))
    plt.subplots_adjust(left=0.05, right=0.95, bottom=0.08, top=0.95)

    dec_lo = -90
    ra_labels_dec = -12 # -30

    dec_gridlines = list(range(max(dec_lo,-80), 90, 10))
    dec_gridlines_ras = np.arange(ra_center-180, ra_center+180, 1)
    ra_gridlines = range(0, 360, 30)
    #ra_gridlines = range(0, 360, 30)
    ra_gridlines_decs = np.arange(dec_lo, 90, 1.)
    dec_gridlines_slope = []
    for d in dec_gridlines:
        rr = dec_gridlines_ras
        dd = np.zeros_like(rr) + d
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)
        dec_gridlines_slope.append((yy[-2]-yy[-1]) / (xx[-2] - xx[-1]))
    for r in ra_gridlines:
        dd = ra_gridlines_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.1)

    ra_gridlines2 = [ra_center-180, ra_center+180]
    ra_gridlines2_decs = np.arange(dec_lo, 91, 1.)
    for r in ra_gridlines2:
        dd = ra_gridlines2_decs
        rr = np.zeros_like(dd) + r
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
        plt.plot(xx, yy, 'k-', alpha=0.5)

    ra_labels = ra_gridlines
    dec_labels = dec_gridlines
    dec_labels_ra = ra_center+180

    ok,xx,yy = wcs.radec2pixelxy(ra_labels, ra_labels_dec)
    for x,y,v in zip(xx, yy, ra_labels):
        plt.text(x, y, '%i'%(v%360), ha='center', va='top', alpha=1, fontsize=12)
    ok,xx,yy = wcs.radec2pixelxy(dec_labels_ra, dec_labels)
    for i,(x,y,v,slope) in enumerate(zip(xx, yy, dec_labels, dec_gridlines_slope)):
        dx = -20
        dy = dx * slope
        r = np.hypot(dx,dy)
        dx = dx * 15 / r
        dy = dy * 15 / r
        #print(v, 'dx,dy', dx, dy)
        plt.text(x+dx, y+dy, '%+i'%v, ha='center', va='center', alpha=1, fontsize=12)
        if v == 0:
            plt.text(x+dx*3, y+dy*3, 'Dec (deg)', ha='center', va='center', rotation=90)
        #if v == 50:
        #    #angle = np.rad2deg(np.arctan2(dy, dx))
        #    angle = np.rad2deg(np.arctan2(yy[i+1]-yy[i-1], xx[i+1]-xx[i-1]))
        #    plt.text(x+dx*3, y+dy*3, 'Dec (deg)', ha='center', va='center', rotation=angle)

    # Galactic plane
    if False:
        ll = np.linspace(0., 360., 720)
        bb = np.zeros_like(ll)
        rr,dd = lbtoradec(ll, bb)
        ok,xx,yy = wcs.radec2pixelxy(rr, dd)
    
        # Label
        ii = np.argmin(np.abs(rr - ra_center+5))
        angle = 185+np.rad2deg(np.arctan2(yy[ii+1]-yy[ii-1], xx[ii+1]-xx[ii-1]))
        #plt.text(xx[ii], yy[ii], 'Galactic Plane', ha='center', va='bottom', 
        #         rotation=angle)#, weight='bold')
    
        # Plot segments that are above min Dec and not discontinuous
        d = np.append([0], np.hypot(np.diff(xx), np.diff(yy)))
        ok = (d < 100) * (dd > dec_lo)
        istart = 0
        while istart < len(ok):
            while istart < len(ok) and ok[istart] == False:
                istart += 1
            iend = istart
            while iend < len(ok) and ok[iend] == True:
                iend += 1
            if iend != istart:
                #print('Plotting from', istart, 'to', iend, 'ok', ok[istart:iend])
                plt.plot(xx[istart:iend], yy[istart:iend], '-', color='0.6', lw=2)
            istart = iend

    #ok,x,y = wcs.radec2pixelxy(ra_center+8, -45)
    ok,x,y = wcs.radec2pixelxy(ra_center, -25)#-105)
    plt.text(x, y, 'RA (deg)', ha='center')

    plt.xticks([])
    plt.yticks([])
    plt.axis('equal');
    #ax = [0,W, 0.2*H, H]
    #plt.axis(ax)
    #plt.axis('equal')
    #plt.axis(ax)
    plt.gca().set_frame_on(False)

    # colorbar
    # Make zero values truly white (cmap.Blue(0) = 0.97,0.98,1.0)
    mycmap = 'Reds' # 'Blues'
    cmap = copy.copy(mpl.colormaps.get_cmap(mycmap))
    cmap.set_bad(color='white')
    density = (sgacount/pixelarea)
    density[sgacount==0] = np.nan

    im = plt.imshow(density, vmin=0, vmax=40, cmap=mycmap, alpha=0.7, origin='lower', interpolation='nearest');
    ax = plt.gca()

    #cax = plt.axes([0.15, 0.08, 0.7, 0.0805])

    div = make_axes_locatable(ax)
    #cax = div.new_horizontal(size="5%", pad=0.2) # pack_start=True
    cax = div.new_vertical(size="5%", pack_start=True, pad=0.2)
    fig.add_axes(cax)

    c = fig.colorbar(im, cax=cax, orientation='horizontal')
    c.set_label(r'Galaxy Surface Density (deg$^{-2}$)')

    fig.subplots_adjust(left=0.05, bottom=0.1, right=0.95, top=0.98)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)
        plt.close(fig)            

def fig_size_mag(sample, leda=False, png=None):
    """D(25) vs Bt from the parent sample and D(25) histogram. 

    """
    import corner

    sns, colors = plot_style(talk=True, font_scale=1.2)

    if leda:
        good = np.where((sample['D25_LEDA'] > 0) * (sample['MAG_LEDA'] > 0))[0]

        isleda = sample['SGA_ID'][good] < 2000000
        notleda = sample['SGA_ID'][good] >= 2000000

        mag_leda = sample['MAG_LEDA'][good][isleda]
        diam_leda = np.log10(sample['D25_LEDA'][good][isleda]) # [arcmin]

        mag_notleda = sample['MAG_LEDA'][good][notleda]
        diam_notleda = np.log10(sample['D25_LEDA'][good][notleda]) # [arcmin]

        xlabel = r'$B_t$ (Vega mag)'
        ylabel = r'$D_{\mathrm{L}}(25)$ (arcmin)'
        #ylabel = r'$D_{i}(25)$ (arcmin)'
    else:
        good = np.where((sample['RADIUS_SB26'] != -1) * (sample['R_MAG_SB26'] != -1))[0]
        mag = sample['R_MAG_SB26'][good]
        diam = np.log10(sample['RADIUS_SB26'][good]/60) # [arcmin]
        xlabel = r'$m_{r}(<R_{26})$ (AB mag)'
        ylabel = r'$R_{26}$ (arcmin)'
    
    xlim, ylim = (7, 20), (-1, 1.6)

    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        else:
            return '{:.1f}'.format(10**x)

    fig = plt.figure(figsize=(14, 7))

    # https://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_hist.html
    #fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 7), sharey=True)
    gs = fig.add_gridspec(1, 2,  width_ratios=(2, 1.1), 
                          #left=0.1, right=0.9, bottom=0.1, top=0.9,
                          wspace=0.05)
    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1], sharey=ax1)
           
    corner.hist2d(mag_leda, diam_leda,
                  levels=[0.5, 0.75, 0.95, 0.995],
                  bins=100, smooth=True, color=colors[0], ax=ax1, # mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k'},
                 )
    #ax1.scatter(mag_leda[:2], diam_leda[:2], s=2, color=colors[0], alpha=0.5, # hack
    #            label='HyperLeda')
    ax1.scatter(mag_notleda, diam_notleda, s=2, color=colors[2], alpha=0.5)#
                #label='Supplemental')

    ax1.yaxis.set_major_formatter(major_formatter)
    ax1.set_yticks(np.log10([0.1, 0.2, 0.5, 1, 2, 5, 10, 25, 40]))
    #ax1.legend(loc='upper right', frameon=False)

    ax1.set_xlim(xlim)
    ax1.set_ylim(ylim)
    ax1.set_xlabel(xlabel)
    ax1.set_ylabel(ylabel)

    #big = np.where(sample['RADIUS_SB26'][good]/60 > 2)[0]
    #ingc = np.where(['NGC' in gg or 'UGC' in gg for gg in sample['GALAXY'][big]])[0]
    #ingc = np.where(['NGC' in gg for gg in sample['GALAXY'][good]])[0]
    #ax.scatter(rmag[ingc], radius[ingc], marker='s', edgecolors='k',
    #           s=10, alpha=1.0, lw=1, color='k')

    ax2.hist(diam_leda, orientation='horizontal', range=ylim, bins=75, 
             color=colors[0], label='HyperLeda')
    ax2.hist(diam_notleda, orientation='horizontal', range=ylim, bins=75, 
             color=colors[2], alpha=0.7, label='Supplemental')
    #ax1.axhline(y=np.log10(20/60), lw=2, ls='-', color='k')
    #ax2.axhline(y=np.log10(20/60), lw=2, ls='-', color='k', label=r'$D_{\mathrm{L}}(25)=20$ arcsec')
    ax2.set_xscale('log')
    ax2.set_xlabel('Number of Galaxies')
    #ax2.spines[['right', 'top']].set_visible(False)
    ax2.tick_params(axis='y', labelleft=False)
    ax2_twin = ax2.twinx()

    ax2_twin.yaxis.set_major_formatter(major_formatter)
    ax2_twin.set_yticks(np.log10([0.1, 0.2, 0.5, 1, 2, 5, 10, 25, 40]))
    #ax2_twin.set_xscale('log')
    ax2_twin.set_ylim(ylim)
    ax2_twin.set_ylabel(ylabel)

    ax2.legend(loc='upper right', fontsize=14) # frameon=False, 
    #hh, ll = ax2.get_legend_handles_labels()
    #ax2.legend([hh[0], hh[1], hh[2]], [ll[0], ll[1], ll[2]], 
    #           loc='upper right', fontsize=14) # frameon=False, 

    fig.subplots_adjust(bottom=0.18, top=0.95, right=0.9, left=0.1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sga_properties(sga, png=None):
    """Corner plot of various properties

    """
    import corner as cn
    from matplotlib.ticker import MaxNLocator, AutoLocator

    sns, colors = plot_style(talk=True, font_scale=0.8)

    I = (sga['R_MAG_SB26'] > 0) * (sga['SMA_SB26'] > 0) #* (sga['D26'] > 0)
    print('Number of galaxies = {}/{}'.format(np.sum(I), len(sga)))
    _sga = sga[I]
    _sga['SB26'] = _sga['R_MAG_SB26'] + 2.5 * np.log10(2 * np.pi * _sga['SMA_SB26']**2)
    #_sga['LOGR50'] = np.log10(_sga['R_SMA50'])
    _sga['LOGR26'] = np.log10(_sga['SMA_SB26'])
    #_sga['LOGD26'] = np.log10(_sga['D26'])
    _sga['EPS'] = 1-_sga['BA']
    Xdata = _sga['R_MAG_SB26', 'LOGR26', 'SB26', 'PA', 'EPS'].to_pandas().values
    lims = [(9, 20), (0.6, 2.6), (21, 28), (-10, 190), (-0.1, 1)]
    #print(lims)

    #pdb.set_trace()

    labels = (r'$m_{r,R(26)}$'+'\n(mag)', 
              r'$\log\,R(26)$'+'\n(arcmin)',
              r'$\langle\, \mu_{r,R(26)}\,\rangle$'+'\n(mag arcsec'+r'$^{-2}$)',
              #r'$D(\mu_{r}=26)$', 
              r'$\phi$'+'\n(degree)', 
              r'$\epsilon$')

    max_n_ticks = 4

    fig = cn.corner(Xdata, labels=labels, fill_contours=True, range=lims, 
                    labelpad=0.08, max_n_ticks=max_n_ticks,
                    smooth=0.8, top_ticks=True,
                    plot_density=True, levels=[0.5, 0.75, 0.95, 0.995],
                    contour_kwargs={'colors': 'k'},
                    #label_kwargs={'fontsize': 14}, 
                    #show_titles=True, 
                    #title_kwargs={'fontsize': 12},
                    hist_kwargs={'color': 'k', 'lw': 2},
                    color=colors[0], quiet=True)#, hist2d_kwargs={'quiet': True},)
    #fig.axes[2].invert_xaxis()
    #fig.axes[0].yaxis.set_major_locator(AutoLocator())
    #fig.axes[0].set_yticklabels([100, 1000, 5000])
    #fig.axes[0].set_ylabel('Number of Galaxies')
    for ii in range(len(labels)):
        xx = fig.axes[ii+ii*5].twiny()
        xx.set_xlim(lims[ii])
        xx.set_xlabel(labels[ii])
        xx.xaxis.set_major_locator(MaxNLocator(max_n_ticks, prune='lower'))
        [l.set_rotation(45) for l in xx.get_xticklabels()]
        [l.set_rotation(45) for l in xx.get_xticklabels(minor=True)]

    #pdb.set_trace()

    fig.subplots_adjust(bottom=0.15, top=0.9, right=0.95, left=0.12)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_redshifts(sga, png=None):
    """Corner plot of various properties

    """
    import astropy.units as u
    from astropy.coordinates import SkyCoord

    sns, colors = plot_style(talk=True, font_scale=1.0)

    zcatfile = os.path.join(paperdir, 'data', 'zall-pix-fuji.fits')
    zcols = ['TARGET_RA', 'TARGET_DEC', 'Z', 'ZWARN', 'ZCAT_PRIMARY']
    zcat = Table(fitsio.read(zcatfile, columns=zcols))
    zcat = zcat[zcat['ZCAT_PRIMARY'] * (zcat['ZWARN'] == 0)]
    print('Read {} primary/good redshifts from {}'.format(len(zcat), zcatfile))

    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_zcat = SkyCoord(ra=zcat['TARGET_RA']*u.deg, dec=zcat['TARGET_DEC']*u.deg)

    rad = 1.0 * u.arcsec
    indx_zcat, indx_sga, d2d, _ = c_sga.search_around_sky(c_zcat, rad)
    print('Found {:,d}/{:,d} DESI-SGA matches within {} arcsec.'.format(len(indx_sga), len(sga), rad))

    #J = zcat['Z'][indx_zcat] > 1
    #sga[indx_sga][J]

    zmin1 = -0.02
    zmax1 = 0.5 # 2.0 # 4.5
    bins = 75

    I = sga['Z_LEDA'] > -1

    fig, ax = plt.subplots()
    ax.hist(sga['Z_LEDA'][I], bins=bins, range=(zmin1, zmax1), color=colors[3], 
            label='HyperLeda')
    ax.hist(zcat['Z'][indx_zcat], bins=bins, range=(zmin1, zmax1), color='k', #colors[2], 
            alpha=0.7, label='DESI/EDR')
    ax.set_xlabel('Heliocentric Redshift')
    ax.set_ylabel('Number of Galaxies')
    #ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_xlim(zmin1, zmax1)
    ax.set_ylim(1, 2e5)
    ax.legend(loc='upper left', fontsize=10)

    # inset
    #M = (zcat['Z'][indx_zcat] > 0) * (sga['Z_LEDA'][indx_sga] > 0)
    M = sga['Z_LEDA'][indx_sga] > -1
    sns, _ = plot_style(talk=True, font_scale=0.5)
    ax2 = fig.add_axes([0.66, 0.6, 0.25, 0.27])
    ax2.scatter(zcat['Z'][indx_zcat][M], sga['Z_LEDA'][indx_sga][M], s=1,
                color=colors[0], marker='s', zorder=1, alpha=0.75)
    ax2.plot([zmin1, zmax1], [zmin1, zmax1], lw=1, color='k', zorder=0)
    ax2.set_xlabel('Redshift [DESI]')
    ax2.set_ylabel('Redshift [HyperLeda]')
    ax2.set_xlim(zmin1, zmax1) 
    ax2.set_ylim(zmin1, zmax1)

    fig.subplots_adjust(left=0.18, bottom=0.15, right=0.95, top=0.95)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_coordinates(sga, png=None):
    """SGA vs HyperLeda coordinate comparisons.

    """
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    import astropy.units as u
    from astropy.coordinates import SkyCoord
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.0)

    montagedir = os.path.join(paperdir, 'data', 'montage-coordinates')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 0.262
    barlen = np.ceil(60 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 5
    nrow = 4
    ngal = ncol * nrow

    # https://cdsarc.u-strasbg.fr/ftp/cats/VII/155/mtypes.tex
    # E      & E    & -5  \\
    # E-S0   & L-:  & -3: \\
    # S0     & L    & -2  \\
    # IrrII  & I0   &  0: \\
    # S0/a   & S0/a &  0  \\
    # Sa     & Sa   &  1  \\
    # Sa-b   & Sab  &  2  \\
    # Sb     & Sb   &  3  \\
    # Sb-c   & Sbc  &  4  \\
    # Sc     & Scd: &  6: \\
    # Sc-Irr & Sdm: &  8: \\
    # IrrI   & Im   & 10  \\
    # S...       & S.      & 3? \\
    # S``early'' & S.(Sa?) & 1? \\
    # S``late''  & S.Sc?   & 5? \\

    morph = sga['MORPHTYPE'].data
    morph = np.char.replace(morph, 'SB', 'S')
    morph = np.char.replace(morph, 'SAB', 'S')
    umorph = set(morph)

    morphkey = {
        '0':        -10, # from openNGC; high surface-brightness
        '.LXS-*.':  -10, # NGC1382, early-type
        'S0':       -10,
        'E':         -4,
        'E?':        -4, # ??
        '.L?....':   -4, # ESO248-6
        '.E+..?.':   -4, # MCG-1-25-6
        '.E+4...':   -4, # ??
        '.E+..P*':   -4, # ??
        '.E...P*':   -4, # ??
        'E-S0':      -3, 
        'S0-a':       0, 
        'Sa':         1,
        'Sab':        2, 
        'Sb':         3,
        '.S..7..':    3, # UGC3694, mid-type
        '.SAR4..':    3, # ESO192-11
        '.SAR5P.':    3, # ESO079-13
        'Sbc':        4, 
        'S?':         5, # ??
        '.S?...':     5, # ??
        '.S?....':    5, # ??
        '.SAS5..':    5, # NGC6050
        'Sc':         6, 
        'Scd':        6, 
        'Sd':         7, 
        '.S.5?P':     7, # ESO159-16, late-type
        '.S.3..':     7, # NGC4858
        'Sm':         8, 
        'I':         10, 
        'IAB':       10, 
        'IB':        10,
        'dSph?':     10, 
        'dIrr':      10, 
        'Irr':       10, 
        '.S..8..':   10, # UGC4258
        '.S..6*.':   10, # UGC5482
        '.I..9P.':   10, # MCG-1-3-72
        '.IBS9..':   99, # ESO298-39, ESO288-40, late-type
        'DLX.0..':   99, # ESO302-15, dwarf
        'COMP':      99, # DR8, ignore
        'EXP':       99, # DR8, ignore
        'DEV':       99, # DR8, ignore
        'DUP':       99, # DR8, ignore
        'REX':       99, # DR8, ignore
        'PSF':       99, # DR8, ignore
        '':          99, # tend to be late-type dwarfs, ignore
        ' ':         99, # tend to be late-type dwarfs, ignore
        'dIrr/dSph': 99, 
        'dSph':      99, 
        'DE.1.P*':   99, # ESO201-10; globular?
        '.L..+P*':   99, # NGC7592 - missing companion/merger
    }

    sga['MORPH'] = np.zeros(len(sga), int)
    for thismorph in umorph:
        I = thismorph == morph
        sga['MORPH'][I] = morphkey[thismorph]

    c_leda = SkyCoord(sga['RA_LEDA']*u.deg, sga['DEC_LEDA']*u.deg)
    c_sga = SkyCoord(sga['RA']*u.deg, sga['DEC']*u.deg)
    _, sep2d, _ = c_leda.match_to_catalog_sky(c_sga)
    print('Mean, min, max delta-theta between SGA and HyperLeda coordinates={:.4f}, {:.4f}, {:.4f} arcsec.'.format(
        np.mean(sep2d.arcsec), np.min(sep2d.arcsec), np.max(sep2d.arcsec)))

    sga['SEP'] = sep2d.arcsec

    print('Galaxies where the coordinates differ by >3 arcsec:')
    I = (sep2d.arcsec > 3) * (sga['D25_LEDA'] > 1) * (sga['D26'] < 14) * (sga['D26_REF'] == 'SB26') * (sga['MORPH'] < 7) #* (sga['DEC'] < 50)
    samp = sga[I]
    samp = samp[np.argsort(samp['D26'])]
    print(len(samp))
    #print(samp['GALAXY', 'RA', 'DEC', 'RA_LEDA', 'DEC_LEDA', 'D25_LEDA', 'D26', 'D26_REF', 'MORPH', 'SEP'])

    if True:
        these = np.where(np.isin(samp['GALAXY'], 
                                 ['PGC132073', 'PGC039869', 'ESO192-11',
                                  'ESO302-012', 'PGC132135', 'NGC1382', 
                                  'PGC039869', 'ESO293-034', 'NGC1511', 'ESO234-042',
                                  'PGC009803', 'UGC11287', 'NGC4636',
                                  'PGC070657', 'NGC1705', 'NGC4020',
                                  'NGC4948', 'NGC4607', 'IC4213',
                                  'NGC6140', 
                                  #'NGC3190', 
                                  'NGC3521', 
                                  #'NGC2403', 
                                  #'NGC0247'
                                  ]))[0]
        samp = samp[these]
    else:
        rand = np.random.RandomState(seed=1)
        these = rand.choice(len(samp), ngal-3, replace=False)
        these = np.hstack((these, 
                           np.where(samp['GALAXY'] == 'NGC2403')[0], 
                           np.where(samp['GALAXY'] == 'ESO192-11')[0],
                           np.where(samp['GALAXY'] == 'PGC039869')[0],
                           ))
        samp = samp[these]
        samp[samp['GALAXY'] == 'PGC009037'] = sga[sga['GALAXY'] == 'NGC0247']
        samp[samp['GALAXY'] == 'PGC025426'] = sga[sga['GALAXY'] == 'ESO293-034']
        samp[samp['GALAXY'] == 'NGC4217'] = sga[sga['GALAXY'] == 'NGC1511']

    samp = samp[np.argsort(samp['D26'])]
    print(samp['GALAXY', 'RA', 'DEC', 'RA_LEDA', 'DEC_LEDA', 'D25_LEDA', 'D26', 'D26_REF', 'MORPH', 'SEP'])

    pngfiles = []
    for onegal  in samp:
        jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['GALAXY']))
        width = int(1.2 * onegal['D26'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['RA'], onegal['DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        rad = 5
        if width < 500:
            lw = 2
        elif width > 2000:
            lw = 7
        else:
            lw = 2

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size

                hdr = fits.Header()
                hdr['NAXIS'] = 2
                hdr['NAXIS1'] = imgsz[0]
                hdr['NAXIS2'] = imgsz[0]
                hdr['CTYPE1'] = 'RA---TAN'
                hdr['CTYPE2'] = 'DEC--TAN'
                hdr['CRVAL1'] = onegal['RA']
                hdr['CRVAL2'] = onegal['DEC']
                hdr['CRPIX1'] = imgsz[0]/2+0.5
                hdr['CRPIX2'] = imgsz[0]/2+0.5
                hdr['CD1_1'] = -pixscale/3600
                hdr['CD1_2'] = 0.0
                hdr['CD2_1'] = 0.0
                hdr['CD2_2'] = +pixscale/3600
                wcs = WCS(hdr)
        
                #draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                #                    onegal['PA'], onegal['D26'] * 60.0, pixscale, color='red')

                onesga = sga[sga['GROUP_NAME'] == onegal['GROUP_NAME']]
                for onesga1 in onesga:
                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA_LEDA'], onesga1['DEC_LEDA'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA_LEDA'], 
                                        onesga1['PA_LEDA'], onesga1['D25_LEDA'] * 60.0, pixscale, 
                                        color='tomato', linewidth=lw)
                    draw = ImageDraw.Draw(colorimg)
                    #draw.rectangle([xpos-rad, imgsz[1]-ypos-rad, xpos+rad, imgsz[1]-ypos+rad], outline='tomato')

                    semimajor = 0.5 * onesga1['D25_LEDA'] * 60 / pixscale # [pixels]
                    semiminor = onesga1['BA_LEDA'] * semimajor            # [pixels]
                    theta = np.radians(onesga1['PA_LEDA'])
                    xymajor = [xpos-semimajor*np.sin(theta), imgsz[1]-(ypos+semimajor*np.cos(theta)),
                               xpos+semimajor*np.sin(theta), imgsz[1]-(ypos-semimajor*np.cos(theta))]
                    xyminor = [xpos-semiminor*np.cos(theta), imgsz[1]-(ypos-semiminor*np.sin(theta)),
                               xpos+semiminor*np.cos(theta), imgsz[1]-(ypos+semiminor*np.sin(theta))]
                    draw.line(xymajor, fill='tomato', width=lw)
                    draw.line(xyminor, fill='tomato', width=lw)

                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                        color='dodgerblue', linewidth=lw)
                    #draw.ellipse([xpos-rad, imgsz[1]-ypos-rad, xpos+rad, imgsz[1]-ypos+rad], fill='dodgerblue')

                    semimajor = 0.5 * onesga1['D26'] * 60 / pixscale # [pixels]
                    semiminor = onesga1['BA'] * semimajor            # [pixels]
                    theta = np.radians(onesga1['PA'])
                    xymajor = [xpos-semimajor*np.sin(theta), imgsz[1]-(ypos+semimajor*np.cos(theta)),
                               xpos+semimajor*np.sin(theta), imgsz[1]-(ypos-semimajor*np.cos(theta))]
                    xyminor = [xpos-semiminor*np.cos(theta), imgsz[1]-(ypos-semiminor*np.sin(theta)),
                               xpos+semiminor*np.cos(theta), imgsz[1]-(ypos+semiminor*np.sin(theta))]
                    draw.line(xymajor, fill='dodgerblue', width=lw)
                    draw.line(xyminor, fill='dodgerblue', width=lw)

                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            label = onegal['GALAXY']
            #label = r'{} ($\Delta\theta={:.1f}"$)'.format(onegal['GALAXY'], onegal['SEP'])
            addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
            #pdb.set_trace()

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 512x512 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        
    
def fig_sga_vs_hyperleda(sga, png=None):
    """SGA improvements vs HyperLeda.

    """
    import corner as cn
    import astropy.units as u
    from astropy.coordinates import SkyCoord

    sns, colors = plot_style(talk=True, font_scale=1.1)

    I = (sga['D26_REF'] != 'LEDA') * (sga['SMA_SB25'] > 0)
    sga = sga[I]

    fig, ax = plt.subplots(2, 2, figsize=(12, 12))

    # coordinatess
    xylim = 20 * np.array([-1, 1])
    dra = (sga['RA'] - sga['RA_LEDA'])*3600
    ddec = (sga['DEC'] - sga['DEC_LEDA'])*3600

    cn.hist2d(dra, ddec, 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[0, 0], smooth=True,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    ax[0, 0].axhline(y=0, color=colors[3], lw=2, alpha=0.7)
    ax[0, 0].axvline(x=0, color=colors[3], lw=2, alpha=0.7)
    ax[0, 0].xaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].yaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].set_xlabel(r'$\Delta\,\mathrm{RA}$ (J2000, arcsec)')
    ax[0, 0].set_ylabel(r'$\Delta\,\mathrm{Dec}$ (J2000, arcsec)')

    # diameters
    xylim = [-1.0, 1.5]
    cn.hist2d(np.log10(2*sga['SMA_SB25']/60), np.log10(sga['D25_LEDA']), 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[0, 1], smooth=True,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    #ax[0, 0].scatter(np.log10(2*sga['SMA_SB25']/60), np.log10(sga['D25_LEDA']), s=1)
    ax[0, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[0, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax[0, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax[0, 1].set_xlabel(r'$D(25)$ [SGA, arcmin]')
    ax[0, 1].set_ylabel(r'$D_{\mathrm{L}}(25)$ [HyperLeda, arcmin]')

    # PA
    xylim = [-10, 190]
    cn.hist2d(sga['PA'], sga['PA_LEDA'], 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[1, 0], smooth=True,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    #ax[0, 1].scatter(sga['PA'], sga['PA_LEDA'], s=1)
    ax[1, 0].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[1, 0].xaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].yaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].set_xlabel(r'$\phi$ [SGA, degree]')
    ax[1, 0].set_ylabel(r'$\phi$ [HyperLeda, degree]')

    # ellipticity
    xylim = [-0.1, 1.1]
    cn.hist2d(1-sga['BA'], 1-sga['BA_LEDA'], 
              levels=[0.5, 0.75, 0.95, 0.995], bins=100, color=colors[0],
              range=[xylim, xylim], ax=ax[1, 1], smooth=True,
              data_kwargs={'color': colors[0], 'alpha': 0.2, 'ms': 4, 'alpha': 0.5},
              contour_kwargs={'colors': 'k'})
    #ax[1, 0].scatter(1-sga['BA'], 1-sga['BA_LEDA'], s=1)
    ax[1, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[1, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].set_xlabel(r'$\epsilon$ [SGA]')
    ax[1, 1].set_ylabel(r'$\epsilon$ [HyperLeda]')

    fig.subplots_adjust(left=0.11, bottom=0.09, right=0.95, top=0.95, hspace=0.2, wspace=0.3)

    #pdb.set_trace()

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)
    
def fig_sga_vs_wxsc100(sga, png=None):
    """Comparison with WXSC largest 100 galaxies.

    """
    import pandas as pd
    import astropy.units as u
    from astropy.coordinates import SkyCoord

    sns, colors = plot_style(talk=True, font_scale=1.1)

    wxscfile = os.path.join(paperdir, 'data', 'wxsc100', 'Table_1.tbl')
    names = ['wxsc_id', 'galaxy', 'ra', 'dec', 'ba', 'pa', 
             'W1_radius', 'W1_mag', 'W1_mag_err',
             'W2_radius', 'W2_mag', 'W2_mag_err',
             'W3_radius', 'W3_mag', 'W3_mag_err',
             'W4_radius', 'W4_mag', 'W4_mag_err',
             'W1_W2', 'W1_W2_err', 'W2_W3', 'W2_W3_err']
    dtype = {'wxsc_id': str, 'galaxy': str, 'ra': np.float64, 'dec': np.float64, 
             'ba': np.float32, 'pa': np.float32, 
             'W1_radius': str, 'W1_mag': str, 'W1_mag_err': str,
             'W2_radius': str, 'W2_mag': str, 'W2_mag_err': str,
             'W3_radius': str, 'W3_mag': str, 'W3_mag_err': str,
             'W4_radius': str, 'W4_mag': str, 'W4_mag_err': str,
             'W1_W2': str, 'W1_W2_err': str, 'W2_W3': str, 'W2_W3_err': str}
    wxsc = pd.read_csv(wxscfile, delimiter='|', comment='#', na_values='null', skiprows=0, 
                       names=names, dtype=dtype, skip_blank_lines=True)#,
                       #warn_bad_lines=True, error_bad_lines=False)
                       
    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_wxsc = SkyCoord(ra=wxsc['ra'].values*u.deg, dec=wxsc['dec'].values*u.deg)

    rad = 10.0 * u.arcsec
    indx_wxsc, indx_sga, d2d, _ = c_sga.search_around_sky(c_wxsc, rad)
    print('Found {:,d}/{:,d} SGA-WXSC matches within {} arcsec.'.format(len(indx_sga), len(sga), rad))
    
    mwxsc = wxsc.iloc[indx_wxsc]
    msga = sga[indx_sga]

    ms = 40
    col = colors[0]

    fig, ax = plt.subplots(2, 2, figsize=(12, 12))

    xylim = 20 * np.array([-1, 1])
    dra = 3600*(msga['RA']-mwxsc['ra'].values)
    ddec = 3600*(msga['DEC']-mwxsc['dec'].values)

    I = dra > 10
    print(msga[I]['GALAXY'].data, msga[I]['RA'].data, msga[I]['DEC'].data, mwxsc.iloc[I]['ra'].values, mwxsc.iloc[I]['dec'].values)
    pdb.set_trace()

    ax[0, 0].scatter(dra, ddec, s=ms, marker='s', color=col)
    ax[0, 0].set_xlim(xylim)
    ax[0, 0].set_ylim(xylim)
    ax[0, 0].axhline(y=0, color=colors[3], lw=2, alpha=0.7)
    ax[0, 0].axvline(x=0, color=colors[3], lw=2, alpha=0.7)
    ax[0, 0].set_xlabel(r'$\Delta\,\mathrm{RA}$ (J2000, arcsec)')
    ax[0, 0].set_ylabel(r'$\Delta\,\mathrm{Dec}$ (J2000, arcsec)')
    ax[0, 0].xaxis.set_major_locator(ticker.MultipleLocator(10))
    ax[0, 0].yaxis.set_major_locator(ticker.MultipleLocator(10))

    xylim = [0.5, 1.75]
    ax[0, 1].scatter(np.log10(msga['D26']), np.log10(2*mwxsc['W1_radius'].values.astype('f4')),
                     s=ms, marker='s', color=col)
    ax[0, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[0, 1].set_xlim(xylim)
    ax[0, 1].set_ylim(xylim)
    ax[0, 1].set_xlabel(r'$D(26)$ [SGA, arcmin]')
    ax[0, 1].set_ylabel(r'$2\times R_{\mathrm{W1}}$ [WXSC-100, arcmin]')
    ax[0, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[0, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))

    xylim = [-10, 190]
    ax[1, 0].scatter(msga['PA'], mwxsc['pa'].values,
                     s=ms, marker='s', color=col)
    ax[1, 0].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[1, 0].set_xlim(xylim)
    ax[1, 0].set_ylim(xylim)
    ax[1, 0].set_xlabel(r'$\phi$ [SGA, degree]')
    ax[1, 0].set_ylabel(r'$\phi$ [WXSC-100, degree]')
    ax[1, 0].xaxis.set_major_locator(ticker.MultipleLocator(50))
    ax[1, 0].yaxis.set_major_locator(ticker.MultipleLocator(50))

    xylim = [-0.1, 1.1]
    ax[1, 1].scatter(1-msga['BA'], 1-mwxsc['ba'].values,
                     s=ms, marker='s', color=col)
    ax[1, 1].plot(xylim, xylim, color=colors[3], lw=2, alpha=0.7)
    ax[1, 1].set_xlim(xylim)
    ax[1, 1].set_ylim(xylim)
    ax[1, 1].set_xlabel(r'$\epsilon$ [SGA]')
    ax[1, 1].set_ylabel(r'$\epsilon$ [WXSC-100]')
    ax[1, 1].xaxis.set_major_locator(ticker.MultipleLocator(0.2))
    ax[1, 1].yaxis.set_major_locator(ticker.MultipleLocator(0.2))

    fig.subplots_adjust(left=0.11, bottom=0.09, right=0.95, top=0.95, hspace=0.2, wspace=0.3)

    #pdb.set_trace()

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)
    
def fig_rich_groups(sga, png=None):
    """Gallery of the richest groups."""

    from PIL import Image
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    montagedir = os.path.join(paperdir, 'data', 'rich-groups')
    if not os.path.isdir(montagedir):
        os.makedirs(montagedir, exist_ok=True)

    pixscale = 1.0 # 0.262
    barlen = np.ceil(60 / pixscale) # [pixels]
    barlabel = '' # '30 arcsec'

    ncol = 1
    nrow = 1
    ngal = ncol * nrow

    #samp = sga[sga['GROUP_PRIMARY'] * (sga['GROUP_MULT'] > 10)]
    samp = sga[sga['GROUP_PRIMARY']]

    #PGC3100847
    samp = sga[sga['GROUP_PRIMARY'] * (sga['GROUP_NAME'] == 'NGC4406_GROUP')]
    print(samp)

    pngfiles = []
    for onegal  in samp:
        jpgfile = os.path.join(montagedir, '{}-rich.jpg'.format(onegal['GALAXY']))
        width = int(2 * onegal['GROUP_DIAMETER'] * 60 / pixscale)
        if not os.path.isfile(jpgfile):
            urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                onegal['GROUP_RA'], onegal['GROUP_DEC'], pixscale, width, width)
            cmd = f'wget -q -O {jpgfile} {urlfile}'
            print(cmd)
            subprocess.call(cmd.split())

        hdr = fits.Header()
        hdr['NAXIS'] = 2
        hdr['NAXIS1'] = width
        hdr['NAXIS2'] = width
        hdr['CTYPE1'] = 'RA---TAN'
        hdr['CTYPE2'] = 'DEC--TAN'
        hdr['CRVAL1'] = onegal['GROUP_RA']
        hdr['CRVAL2'] = onegal['GROUP_DEC']
        hdr['CRPIX1'] = width/2+0.5
        hdr['CRPIX2'] = width/2+0.5
        hdr['CD1_1'] = -pixscale/3600
        hdr['CD1_2'] = 0.0
        hdr['CD2_1'] = 0.0
        hdr['CD2_2'] = +pixscale/3600
        wcs = WCS(hdr)

        pngfile1 = jpgfile.replace('.jpg', '.png')
        if not os.path.isfile(pngfile1):
            with Image.open(jpgfile) as colorimg:
                imgsz = colorimg.size
                #draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                #                    onegal['PA'], onegal['D26'] * 60.0, pixscale, color='red')

                onesga = sga[sga['GROUP_NAME'] == onegal['GROUP_NAME']]
                for onesga1 in onesga:
                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, color='blue')
                print(f'Writing {pngfile1}')
                colorimg.save(pngfile1)

            addbar_to_png(pngfile1, barlen, barlabel, onegal['GROUP_NAME'].replace('_GROUP', ' Group'), 
                          pngfile1, scaledfont=True)

        pngfiles.append(pngfile1)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
    
        cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
        cmd = cmd+' '.join([pngf for pngf in pngfiles])
        cmd = cmd+' {}'.format(pngfile)
        print(cmd)
        os.system(cmd)        

def fig_sb_mag(sga, parent, frac=None, png=None):
    """Surface brightness vs r-band magnitude.
    
    """
    import corner
    from astropy.table import Table

    sns, _ = plot_style(talk=True, font_scale=1.2)

    def makeplot(mag, sb, xlim, ylim):
        fig, ax = plt.subplots(figsize=(8, 6))
        corner.hist2d(rmag, sb, levels=[0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                      bins=100, smooth=True, color='tan', ax=ax, # mpl.cm.get_cmap('viridis'),
                      plot_density=True, fill_contours=True, range=(xlim, ylim),
                      data_kwargs={'color': 'navy', 'alpha': 0.2, 'ms': 3},
                      contour_kwargs={'colors': 'k'}
                     )
               
        # overplot lines of constant size
        magarr = np.linspace(xlim[0], xlim[1], 50)
        for size, xpos, ypos in zip((5, 10, 30, 100, 300),
                                    (None, None, None, None, None),
                                    (22.0, 22.0, 22.0, 22.0, 23.0)):
            sbarr = magarr + 2.5 * np.log10(2 * np.pi * size**2)
            ax.plot(magarr, sbarr, color='blue', lw=2, ls='--', alpha=0.8)
            
            if ypos:
                xpos = ypos - 2.5 * np.log10(2 * np.pi * size**2)
            if xpos:
                ypos = xpos + 2.5 * np.log10(2 * np.pi * size**2)
                
            ax.text(xpos, ypos, r'$R_{{26}}={0:g}^{{\prime\prime}}$'.format(size), 
                    ha='left', va='center', rotation=-60, fontsize=16, alpha=1.0)
    
        # labels and all that
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        #ax.xmargins(0)
        ax.set_xlabel(r'$m_{r}$ (AB mag)')
        ax.set_ylabel(r'$\langle \mu_{r, R_{26}}\rangle$ (AB mag arcsec$^{-2}$)')
        
        fig.subplots_adjust(bottom=0.15, top=0.95, right=0.95, left=0.15)

        return fig

    # parent plot
    good = np.where((parent['SMA_SB26'] != -1) * (parent['R_MAG_SB26'] != -1))[0]
    rmag = parent['R_MAG_SB26'][good]
    radius = parent['SMA_SB26'][good] # [arcsec]
    sb = parent + 2.5 * np.log10(2 * np.pi * radius**2)
    xlim = (8, 20)
    ylim = (27, 21)
    fig = makeplot(rmag, sb, xlim, ylim)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    # SGA plot
    good = np.where((sga['SMA_SB26'] != -1) * (sga['R_MAG_SB26'] != -1))[0]
    rmag = sga['R_MAG_SB26'][good]
    radius = sga['SMA_SB26'][good] # [arcsec]
    sb = rmag + 2.5 * np.log10(2 * np.pi * radius**2)
    xlim = (8, 20)
    ylim = (27, 21)
    fig = makeplot(rmag, sb, xlim, ylim)

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sbmontage(onegal, igal=0, colorlim=(0.0, 1.5), png=None):
    """Make one large figure with the surface brightness profile fitting results for
    a single galaxy.

    """
    import numpy.ma as ma

    from PIL import Image, ImageDraw, ImageFont
    from photutils.aperture import EllipticalAperture
    import matplotlib.patches as mpatches

    from astropy.visualization import ImageNormalize
    from astropy.visualization import AsinhStretch as Stretch
    from astropy.visualization import ZScaleInterval as Interval

    from legacyhalos.io import read_ellipsefit
    from legacyhalos.ellipse import ellipse_sbprofile, CogModel
    from legacyhalos.qa import _sbprofile_colors
    from legacyhalos.SGA import read_multiband, SBTHRESH, cog_model

    sns, _ = plot_style(talk=True, font_scale=1.4)
    
    # https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html
    #cmap = plt.cm.plasma
    #cmap = plt.cm.cividis
    cmap = plt.cm.inferno
    #cmap = plt.cm.viridis
    stretch = Stretch(a=0.9)
    interval = Interval(contrast=0.5, n_samples=10000)

    filesuffix = 'largegalaxy'

    #print(sample)
    galaxy, galaxydir = get_galaxy_galaxydir(onegal)
    #this = np.where(galaxy == thisgalaxy)[0][0]
    #onegal, galaxy, galaxydir = np.atleast_1d(sample)[this], np.atleast_1d(galaxy)[this], np.atleast_1d(galaxydir)[this]

    data, galaxyinfo = read_multiband(galaxy, galaxydir, filesuffix=filesuffix, verbose=True)

    galaxy_id = '{}'.format(data['galaxy_id'][igal])
    #galaxy_id = '1121465'
    #galaxy_indx = 1

    # Read the data and the ellipse-fitting results.
    ellipsefile = os.path.join(galaxydir, '{}-{}-{}-ellipse.fits'.format(galaxy, filesuffix, galaxy_id))
    ellipsefit = read_ellipsefit(galaxy, galaxydir, ellipsefitfile=ellipsefile, verbose=True)
    #ellipsefit = read_ellipsefit(galaxy, galaxydir, filesuffix=filesuffix, galaxy_id=galaxy_id, verbose=True)

    # old data model
    ellipsefit['eps_moment'] = ellipsefit['eps'] 
    ellipsefit['sma_g'] = ellipsefit['g_sma'] 
    ellipsefit['sma_r'] = ellipsefit['r_sma'] 
    ellipsefit['sma_z'] = ellipsefit['z_sma'] 
    ellipsefit['intens_g'] = ellipsefit['g_intens'] 
    ellipsefit['intens_r'] = ellipsefit['r_intens'] 
    ellipsefit['intens_z'] = ellipsefit['z_intens'] 
    ellipsefit['intens_err_g'] = ellipsefit['g_intens_err'] 
    ellipsefit['intens_err_r'] = ellipsefit['r_intens_err'] 
    ellipsefit['intens_err_z'] = ellipsefit['z_intens_err'] 

    scaledfont = True
    barlen_arcsec = 60.0 # [arcsec]
    barlen = np.ceil(barlen_arcsec / data['refpixscale']).astype(int) # [pixels]
    #barlen_kpc = barlen_arcsec * arcsec2kpc
    
    barlabel = '1 arcmin'
    #barlabel = '1 arcmin = {:.0f} kpc'.format(barlen_kpc)

    band = data['bands']
    nband = len(band)

    nplot = 12
    sma_lw = 2
    sma_alpha = 0.8

    #fig, ax = plt.subplots(1, 3, figsize=(8*3, 8), sharex=True)
    fig = plt.figure(figsize=(16, 16))
    gs1 = fig.add_gridspec(3, 1, bottom=0.04, top=0.96, left=0.0, right=0.35,
                           height_ratios=[1, 1, 1], hspace=0.03)

    ax0 = fig.add_subplot(gs1[0])
    with Image.open(os.path.join(galaxydir, '{}-{}-image-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Stack'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)
            
        if barlen and barlabel:
            width = np.round(sz[0]/150).astype('int')
            # Add a scale bar and label--
            x0, x1, y0, y1 = 0+fntsize*1.5, 0+fntsize*2+barlen, sz[1]-fntsize*2, sz[1]-fntsize*2.5
            draw.line((x0, y1, x1, y1), fill='white', width=width)
            ww = draw.textlength(barlabel, font=font)
            dx = ((x1-x0) - ww)//2
            #print(x0, x1, y0, y1, ww, x0+dx, sz)
            draw.text((x0+dx, y0), barlabel, font=font)

        # First display the data mosaic
        ax0.imshow(img, interpolation='nearest')
        ax0.xaxis.set_ticklabels([])
        ax0.yaxis.set_ticklabels([])
        ax0.xaxis.set_ticks([])
        ax0.yaxis.set_ticks([])

    # Now the model mosaic
    ax1 = fig.add_subplot(gs1[1])
    with Image.open(os.path.join(galaxydir, '{}-{}-model-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Model'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)

        ax1.imshow(img, interpolation='nearest')
        ax1.xaxis.set_ticklabels([])
        ax1.yaxis.set_ticklabels([])
        ax1.xaxis.set_ticks([])
        ax1.yaxis.set_ticks([])

    filt = 'r'
    dat = data['{}_masked'.format(filt)][igal]
    img = ma.masked_array(dat.data, dat.mask)
    mask = ma.masked_array(dat.data, ~dat.mask)

    try:
        norm = ImageNormalize(img, interval=interval, stretch=stretch)
    except:
        norm = ImageNormalize(img, interval=interval)

    ax2 = fig.add_subplot(gs1[2])
    ax2.imshow(dat, origin='lower', norm=norm, cmap=cmap, #cmap=cmap[filt],
               interpolation='nearest')
    txt = plt.text(0.08, 0.9, r'${}$-band Image'.format(filt), transform=ax2.transAxes, #fontweight='bold',
                   ha='left', va='center', color='k', fontsize=18)
    #txt.set_bbox(dict(facecolor='gray', alpha=0.5))

    smas = np.linspace(0, ellipsefit['{}_sma'.format(filt)].max(), nplot)
    for sma in smas:
        this = np.argmin(np.abs(ellipsefit['{}_sma'.format(filt)]-sma))
        ax2.add_patch(mpatches.Ellipse((ellipsefit['{}_x0'.format(filt)][this], ellipsefit['{}_y0'.format(filt)][this]),
                                       2*ellipsefit['{}_sma'.format(filt)][this],
                                       2*ellipsefit['{}_sma'.format(filt)][this]*(1-ellipsefit['{}_eps'.format(filt)][this]),
                                       angle=ellipsefit['{}_pa'.format(filt)][this]-90,
                                       color='k', lw=sma_lw, alpha=sma_alpha, fill=False))#, label='Fitted isophote')

    for xx in (ax0, ax1, ax2):
        xx.xaxis.set_ticklabels([])
        xx.yaxis.set_ticklabels([])
        xx.xaxis.set_ticks([])
        xx.yaxis.set_ticks([])

    ## [1] vertical 3-panel showing the grz data and ellipse samples
    #for ii, filt in enumerate(band):
    #    xx = fig.add_subplot(gs1[ii])
    #    
    #    dat = data['{}_masked'.format(filt)][igal]
    #    img = ma.masked_array(dat.data, dat.mask)
    #    mask = ma.masked_array(dat.data, ~dat.mask)
    #
    #    try:
    #        norm = ImageNormalize(img, interval=interval, stretch=stretch)
    #    except:
    #        norm = ImageNormalize(img, interval=interval)
    #
    #    xx.imshow(dat, origin='lower', norm=norm, cmap=cmap, #cmap=cmap[filt],
    #               interpolation='nearest')
    #    plt.text(0.1, 0.9, filt, transform=xx.transAxes, fontweight='bold',
    #             ha='center', va='center', color='k', fontsize=26)
    #
    #    smas = np.linspace(0, ellipsefit['{}_sma'.format(filt)].max(), nplot)
    #    for sma in smas:
    #        this = np.argmin(np.abs(ellipsefit['{}_sma'.format(filt)]-sma))
    #        xx.add_patch(mpatches.Ellipse((ellipsefit['{}_x0'.format(filt)][this], ellipsefit['{}_y0'.format(filt)][this]),
    #                                       2*ellipsefit['{}_sma'.format(filt)][this],
    #                                       2*ellipsefit['{}_sma'.format(filt)][this]*(1-ellipsefit['{}_eps'.format(filt)][this]),
    #                                       ellipsefit['{}_pa'.format(filt)][this]-90,
    #                                       color='k', lw=sma_lw, alpha=sma_alpha, fill=False))#, label='Fitted isophote')
    #
    #    xx.xaxis.set_ticklabels([])
    #    xx.yaxis.set_ticklabels([])
    #    xx.xaxis.set_ticks([])
    #    xx.yaxis.set_ticks([])

    # [2] surface brightness and color profile
    gs2 = fig.add_gridspec(3, 1, bottom=0.08, top=0.93, left=0.42,
                           right=0.98, hspace=0.04, height_ratios=[2.9, 1.4, 2])
    
    minerr, use_ylim, plot_radius = 0.0, None, False
    
    sbprofile = ellipse_sbprofile(ellipsefit, minerr=minerr, sma_not_radius=~plot_radius,
                                  cut_on_cog=False)
    colors = _sbprofile_colors(makeiter=True)

    bands = ellipsefit['bands']
    refband = ellipsefit['refband']

    yminmax = [40, 0]
    xminmax = [1.0, 0]
    #xminmax = [1.0, 0]

    #fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True,
    #                               gridspec_kw = {'height_ratios':[2, 1]})
    ax1 = fig.add_subplot(gs2[0])
    ax2 = fig.add_subplot(gs2[1])#, sharex=ax1)
    for filt in bands:
        col = next(colors)

        mu = sbprofile['mu_{}'.format(filt)]
        muerr = sbprofile['muerr_{}'.format(filt)]
        if len(mu) == 0 or mu[0] == -1: # no good data
            continue
        radius = sbprofile['radius_{}'.format(filt)]**0.25

        ax1.fill_between(radius, mu-muerr, mu+muerr, label=r'${}$'.format(filt),
                         facecolor=col, edgecolor='k', lw=2, alpha=0.75)

        if np.nanmin(mu-muerr) < yminmax[0]:
            yminmax[0] = np.nanmin(mu-muerr)
        if np.nanmax(mu+muerr) > yminmax[1]:
            yminmax[1] = np.nanmax(mu+muerr)
        if np.nanmax(radius) > xminmax[1]:
            xminmax[1] = np.nanmax(radius)

    ax1.set_ylabel(r'$\mu(r)$ (mag arcsec$^{-2}$)')
    #ax1.set_ylabel(r'Surface Brightness $\mu(a)$ (mag arcsec$^{-2}$)')

    ylim = [yminmax[0]-0.75, yminmax[1]+0.5]
    if ylim[0] < 17:
        ylim[0] = 17
    if ylim[1] > 33:
        ylim[1] = 33

    if use_ylim is not None:
        ax1.set_ylim(use_ylim)
    else:
        ax1.set_ylim(ylim)
    ax1.invert_yaxis()

    xlim = [xminmax[0], xminmax[1]*1.0]
    ax1.set_xlim(xlim)

    hh, ll = ax1.get_legend_handles_labels()
    if len(hh) > 0:
        leg1 = ax1.legend(loc='upper right', fontsize=18, frameon=True)
        #ax1.set_title('{} ({})'.format(onegal['GALAXY'][0], onegal['GROUP_NAME'][0].replace('_', ' ')))
        ax1.set_title(galaxyinfo[igal]['galaxy'][0])

    # Now the color-radius plot
    if sbprofile['radius_gr'][0] != -1:
        ax2.fill_between(sbprofile['radius_gr']**0.25,
                         sbprofile['gr'] - sbprofile['gr_err'],
                         sbprofile['gr'] + sbprofile['gr_err'],
                         label=r'$g - r$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    if sbprofile['radius_rz'][0] != -1:
        ax2.fill_between(sbprofile['radius_rz']**0.25,
                         sbprofile['rz'] - sbprofile['rz_err'],
                         sbprofile['rz'] + sbprofile['rz_err'],
                         label=r'$r - z$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    hh, ll = ax2.get_legend_handles_labels()
    if len(hh) > 0:
        ax2.legend(loc='upper right', fontsize=18, frameon=True)
        #ax2.legend(bbox_to_anchor=(0.25, 0.98))

    ax2.set_ylabel('Color (mag)')
    ax2.set_ylim(colorlim)
    ax2.set_xlim(xlim)
    #ax2.autoscale(False) # do not scale further

    for xx in (ax1, ax2):
        xx.margins(x=0)
        xx.xaxis.set_ticklabels([])
        ylim = xx.get_ylim()
        xx.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                        [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)

    #ax2.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #    transform=ax2.transAxes, fontsize=10)
    ax1.text(0.07, 0.1, 'PSF\n(2$\sigma$)', ha='center', va='center',
             transform=ax1.transAxes, fontsize=18)

    # [3] curve of growth
    ax3 = fig.add_subplot(gs2[2])#, sharex=ax2)
    colors = _sbprofile_colors()
    colors2 = iter(['navy', 'darkgreen', 'tomato'])
    marker = iter(['s', 'o', '^'])

    radkeys = ['SMA_SB{:0g}'.format(sbcut) for sbcut in SBTHRESH]
    sma_arcsec = np.array(list(onegal[radkeys].as_array()[0])) # semi-major axis, arcsec
    xplot_arcsec = np.linspace(0.01, 1.05*xlim[1]**4, 100)
    #xplot_arcsec = np.linspace(0.01, 1.3*np.max(sma_arcsec), 100)

    maxsma = 0
    eps = ellipsefit['eps']

    yfaint, ybright = 0, 50
    for filt in bands:
        col = next(colors) # iterate here in case we're missing a bandpass
        col2 = next(colors2)
        mark = next(marker)

        magkeysfilt = [radkey.replace('SMA_', '{}_MAG_'.format(filt.upper())) for radkey in radkeys]
        magerrkeysfilt = ['{}_ERR'.format(magkeyfilt) for magkeyfilt in magkeysfilt]
        cogmag = np.array(list(onegal[magkeysfilt].as_array()[0]))
        cogmagerr = np.sqrt((np.array(list(onegal[magerrkeysfilt].as_array()[0])))**2 + minerr**2)

        these = np.where((sma_arcsec > 0) * (cogmag > 0) * (cogmagerr > 0))[0]
        cog = cogmag[these]
        cogerr = cogmagerr[these]
        sma = sma_arcsec[these]

        magtot = onegal['{}_COG_PARAMS_MTOT'.format(filt.upper())][0]
        m0 = onegal['{}_COG_PARAMS_M0'.format(filt.upper())][0]
        alpha1 = onegal['{}_COG_PARAMS_ALPHA1'.format(filt.upper())][0]
        alpha2 = onegal['{}_COG_PARAMS_ALPHA2'.format(filt.upper())][0]
        chi2 = onegal['{}_COG_PARAMS_CHI2'.format(filt.upper())][0]
        #print(filt, magtot, m0, alpha1, alpha2)

        label = r'${}={:.3f}$'.format(filt, magtot)
        #label = r'${}={:.3f}\ (\chi^{{2}}_{{\nu}}={:.2f})$'.format(filt, magtot, chi2)
        #label = r'${}$'.format(filt)

        ax3.errorbar(sma**0.25, cog, cogerr, fmt=mark, color=col, label=label,
                     markersize=10, capthick=2, capsize=2)

        yplot_mag = cog_model(xplot_arcsec, magtot, m0, alpha1, alpha2)
        ax3.plot(xplot_arcsec**0.25, yplot_mag, color=col2, lw=2, ls='-', alpha=0.5)

        if np.max(sma) > maxsma:
            maxsma = np.max(sma)

        if cog.max() > yfaint:
            yfaint = cog.max()
        if cog.min() < ybright:
            ybright = cog.min()

    ax3.set_xlabel(r'(Semi-major axis / arcsec)$^{1/4}$')
    ax3.set_ylabel(r'm$(<r)$ (mag)')
    #ax3.margins(x=0)
    ax3.set_xlim(xlim)
        
    yfaint += 1.0 # 0.7
    ybright += -0.5 # -0.7
    ax3.set_ylim(yfaint, ybright)
    #ax3.xaxis.set_major_locator(ticker.MultipleLocator(0.5))

    if False:
        ax_twin = ax.twinx()
        ax_twin.set_ylim(yfaint, ybright)
        ax_twin.set_ylabel('Cumulative Flux (AB mag)')#, rotation=-90)

    if False:
        hh, ll = ax3.get_legend_handles_labels()
        if len(hh) > 0:
            leg1 = ax3.legend(loc='lower right', fontsize=14)#, ncol=3)

    ylim = ax3.get_ylim()
    ax3.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                     [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)
    #ax3.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #         transform=ax3.transAxes, fontsize=16)

        
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_sbmontage_gallery(onegal, png):
    """Like fig_sbmontage but with fewer panels so the figures can be used in
    landscape mode for the poster gallery.

    """
    import numpy.ma as ma

    from PIL import Image, ImageDraw, ImageFont
    from photutils import EllipticalAperture
    import matplotlib.patches as mpatches

    from astropy.visualization import ImageNormalize
    from astropy.visualization import AsinhStretch as Stretch
    from astropy.visualization import ZScaleInterval as Interval

    from legacyhalos.io import read_ellipsefit
    from legacyhalos.ellipse import ellipse_sbprofile, CogModel
    from legacyhalos.qa import _sbprofile_colors
    from legacyhalos.SGA import read_multiband

    sns, _ = plot_style(talk=True, font_scale=1.4)
    
    # https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html
    #cmap = plt.cm.plasma
    #cmap = plt.cm.cividis
    cmap = plt.cm.inferno
    #cmap = plt.cm.viridis
    stretch = Stretch(a=0.9)
    interval = Interval(contrast=0.5, n_samples=10000)

    filesuffix = 'largegalaxy'

    #print(sample)
    galaxy, galaxydir = get_galaxy_galaxydir(onegal)
    #this = np.where(galaxy == thisgalaxy)[0][0]
    #onegal, galaxy, galaxydir = np.atleast_1d(sample)[this], np.atleast_1d(galaxy)[this], np.atleast_1d(galaxydir)[this]

    data, galaxyinfo = read_multiband(galaxy, galaxydir, filesuffix=filesuffix, verbose=True)

    igal = 0
    galaxy_id = '{}'.format(data['galaxy_id'][igal])
    #galaxy_id = '1121465'
    #galaxy_indx = 1

    # Read the data and the ellipse-fitting results.
    ellipsefit = read_ellipsefit(galaxy, galaxydir, filesuffix=filesuffix, galaxy_id=galaxy_id, verbose=True)

    scaledfont = True
    barlen_arcsec = 60.0 # [arcsec]
    barlen = np.ceil(barlen_arcsec / data['refpixscale']).astype(int) # [pixels]
    #barlen_kpc = barlen_arcsec * arcsec2kpc
    
    barlabel = '1 arcmin'
    #barlabel = '1 arcmin = {:.0f} kpc'.format(barlen_kpc)

    band = data['bands']
    nband = len(band)

    nplot = 12
    sma_lw = 2
    sma_alpha = 0.8

    #fig, ax = plt.subplots(1, 3, figsize=(8*3, 8), sharex=True)
    fig = plt.figure(figsize=(16, 9))
    gs1 = fig.add_gridspec(2, 1, bottom=0.04, top=0.96, left=0.0, right=0.35,
                           height_ratios=[1, 1], hspace=0.03)

    ax0 = fig.add_subplot(gs1[0])
    with Image.open(os.path.join(galaxydir, '{}-{}-image-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Stack'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)
            
        if barlen and barlabel:
            width = np.round(sz[0]/150).astype('int')
            # Add a scale bar and label--
            x0, x1, y0, y1 = 0+fntsize*1.5, 0+fntsize*2+barlen, sz[1]-fntsize*2, sz[1]-fntsize*2.5
            draw.line((x0, y1, x1, y1), fill='white', width=width)
            ww = draw.textlength(barlabel, font=font)
            dx = ((x1-x0) - ww)//2
            #print(x0, x1, y0, y1, ww, x0+dx, sz)
            draw.text((x0+dx, y0), barlabel, font=font)

        # First display the data mosaic
        ax0.imshow(img, interpolation='nearest')
        ax0.xaxis.set_ticklabels([])
        ax0.yaxis.set_ticklabels([])
        ax0.xaxis.set_ticks([])
        ax0.yaxis.set_ticks([])

    # Now the model mosaic
    ax1 = fig.add_subplot(gs1[1])
    with Image.open(os.path.join(galaxydir, '{}-{}-model-grz.jpg'.format(galaxy, filesuffix))) as img:
        draw = ImageDraw.Draw(img)
        sz = img.size
        if scaledfont:
            fntsize = np.round(sz[0]/20).astype('int')
        else:
            fntsize = 20 # np.round(sz[0]/20).astype('int')
        font = ImageFont.truetype(fonttype, size=fntsize)

        txt = 'Image Model'
        ww = draw.textlength(txt, font=font)
        x0, x1, y0 = 0+fntsize*0.8, 0+fntsize*1.5+ww, fntsize*1.5
        dx = ((x1-x0) - ww)//2
        draw.text((x0+dx, y0), txt, font=font)

        ax1.imshow(img, interpolation='nearest')
        ax1.xaxis.set_ticklabels([])
        ax1.yaxis.set_ticklabels([])
        ax1.xaxis.set_ticks([])
        ax1.yaxis.set_ticks([])

    for xx in (ax0, ax1):
        xx.xaxis.set_ticklabels([])
        xx.yaxis.set_ticklabels([])
        xx.xaxis.set_ticks([])
        xx.yaxis.set_ticks([])

    # [2] surface brightness and color profile
    gs2 = fig.add_gridspec(2, 1, bottom=0.12, top=0.93, left=0.42,
                           right=0.98, hspace=0.04, height_ratios=[2.9, 1.4])
    
    minerr, use_ylim, plot_radius = 0.0, None, False
    
    sbprofile = ellipse_sbprofile(ellipsefit, minerr=minerr, sma_not_radius=~plot_radius,
                                  cut_on_cog=False)
    colors = _sbprofile_colors(makeiter=True)

    bands = ellipsefit['bands']
    refband = ellipsefit['refband']

    yminmax = [40, 0]
    xminmax = [0.9, 0]
    #xminmax = [1, 0]

    ax1 = fig.add_subplot(gs2[0])
    ax2 = fig.add_subplot(gs2[1], sharex=ax1)
    for filt in bands:
        col = next(colors)

        mu = sbprofile['mu_{}'.format(filt)]
        muerr = sbprofile['muerr_{}'.format(filt)]
        if len(mu) == 0 or mu[0] == -1: # no good data
            continue
        radius = sbprofile['radius_{}'.format(filt)]**0.25

        ax1.fill_between(radius, mu-muerr, mu+muerr, label=r'${}$'.format(filt),
                         facecolor=col, edgecolor='k', lw=2, alpha=0.75)

        if np.nanmin(mu-muerr) < yminmax[0]:
            yminmax[0] = np.nanmin(mu-muerr)
        if np.nanmax(mu+muerr) > yminmax[1]:
            yminmax[1] = np.nanmax(mu+muerr)
        if np.nanmax(radius) > xminmax[1]:
            xminmax[1] = np.nanmax(radius)

    ax1.set_ylabel(r'$\mu(r)$ (mag arcsec$^{-2}$)')
    #ax1.set_ylabel(r'Surface Brightness $\mu(a)$ (mag arcsec$^{-2}$)')

    ylim = [yminmax[0]-0.75, yminmax[1]+0.5]
    if ylim[0] < 17:
        ylim[0] = 17
    if ylim[1] > 33:
        ylim[1] = 33

    if use_ylim is not None:
        ax1.set_ylim(use_ylim)
    else:
        ax1.set_ylim(ylim)
    ax1.invert_yaxis()

    xlim = [xminmax[0], xminmax[1]*1.0]
    ax1.set_xlim(xlim)

    hh, ll = ax1.get_legend_handles_labels()
    if len(hh) > 0:
        leg1 = ax1.legend(loc='upper right', fontsize=18, frameon=True)
        if onegal['GROUP_MULT'] > 1:
            ax1.set_title('{} ({})'.format(onegal['GALAXY'], onegal['GROUP_NAME'].replace('_', ' ')))
        else:
            ax1.set_title(onegal['GALAXY'])
        #ax1.set_title(galaxyinfo[igal]['galaxy'][0])

    # Now the color-radius plot
    if sbprofile['radius_gr'][0] != -1:
        ax2.fill_between(sbprofile['radius_gr']**0.25,
                         sbprofile['gr'] - sbprofile['gr_err'],
                         sbprofile['gr'] + sbprofile['gr_err'],
                         label=r'$g - r$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    if sbprofile['radius_rz'][0] != -1:
        ax2.fill_between(sbprofile['radius_rz']**0.25,
                         sbprofile['rz'] - sbprofile['rz_err'],
                         sbprofile['rz'] + sbprofile['rz_err'],
                         label=r'$r - z$', facecolor=next(colors), alpha=0.75,
                         edgecolor='k', lw=2)

    hh, ll = ax2.get_legend_handles_labels()
    if len(hh) > 0:
        ax2.legend(loc='upper right', fontsize=18, frameon=True)
        #ax2.legend(bbox_to_anchor=(0.25, 0.98))

    ax2.set_ylabel('Color (mag)')
    ax2.set_ylim(-1, 2)
    ax2.set_xlim(xlim)
    #ax2.autoscale(False) # do not scale further

    for xx in (ax1, ax2):
        xx.margins(x=0)
        #xx.xaxis.set_ticklabels([])
        ylim = xx.get_ylim()
        xx.fill_between([0, (2*ellipsefit['psfsize_r'])**0.25],
                        [ylim[0], ylim[0]], [ylim[1], ylim[1]], color='grey', alpha=0.1)

    #ax2.text(0.05, 0.15, 'PSF\n(3$\sigma$)', ha='center', va='center',
    #    transform=ax2.transAxes, fontsize=10)
    ax1.text(0.07, 0.1, 'PSF\n(2$\sigma$)', ha='center', va='center',
             transform=ax1.transAxes, fontsize=18)

    ax2.set_xlabel(r'Semi-major axis $r^{1/4}$ (arcsec)$^{1/4}$')
        
    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_nsa_completeness(sga, png=None):
    """Quantify the sample completeness by comparing against the NSA

    """
    import corner
    from glob import glob
    import healpy as hp
    import astropy.units as u
    from astropy.table import vstack
    from astropy.coordinates import SkyCoord
    from pydl.pydlutils.yanny import read_table_yanny
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.3)

    # http://nsatlas.org
    # https://www.sdss4.org/dr17/manga/manga-target-selection/nsa/
    nsafile = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.fits')
    nsadr9file = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.dr9.fits')
    nsanodr9file = os.path.join(paperdir, 'data', 'nsa', 'nsa_v1_0_1.nodr9.fits')
    if not os.path.isfile(nsadr9file):
        nsa = Table(fitsio.read(nsafile))
        print('Read {} galaxies from {}'.format(len(nsa), nsafile))
    
        # remove bad deblends
        comm = read_table_yanny(os.path.join(paperdir, 'data', 'nsa', 'nsa_comments.par'), 'COMMENT')
        bad = np.zeros(len(comm), bool)
        for ii, comment in enumerate(comm['comment']):
            comment = comment.lower()
            if 'bad' in comment or 'poor' in comment:
                bad[ii] = True
        bad = np.where(bad)[0]
        print('Removing {} bad or poor deblends'.format(len(bad)))

        nsa = nsa[np.logical_not(np.isin(nsa['NSAID'], comm['nsaid'][bad]))]
    
        # only keep objects in the LS/DR9 footprint
        randomfiles = glob(os.path.join(paperdir, 'data', 'randoms-1-*.fits'))
        rand = []
        for randomfile in randomfiles:
            print('Reading {}'.format(randomfile))
            rand1 = fitsio.read(randomfile, columns=['NOBS_G', 'NOBS_R', 'NOBS_Z'])
            I = np.where((rand1['NOBS_G'] > 0) * (rand1['NOBS_R'] > 0) * (rand1['NOBS_Z'] > 0))[0]
            rand.append(Table(fitsio.read(randomfile, columns=['RA', 'DEC'], rows=I)))
        rand = vstack(rand)
        print('Read {:,d} random points from {} randomfiles.'.format(len(rand), len(randomfiles)))

        c_nsa = SkyCoord(nsa['RA']*u.deg, nsa['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        rad = 2 * u.arcmin
        _, indx_nsa, d2d, _ = c_nsa.search_around_sky(c_rand, rad)
        indx_nsa = np.sort(np.unique(indx_nsa))
        print('Matched {}/{} NSA galaxies to a DR9 random point with NOBS_[GRZ]>1'.format(len(indx_nsa), len(nsa)))
    
        nsa_nodr9 = nsa[np.delete(np.arange(len(nsa)), indx_nsa)]

        #c_nsa2 = SkyCoord(nsa_nodr9['RA'][:10]*u.deg, nsa_nodr9['DEC'][:10]*u.deg)
        #_, sep2d, _ = c_nsa2.match_to_catalog_sky(c_rand)
        #print(sep2d.arcsec)
        #plt.clf() ; plt.scatter(rand['RA'], rand['DEC'], s=1) ; plt.ylim(-1., -0.5) ; plt.xlim(145.5, 146) ; plt.scatter(nsa_nodr9['RA'], nsa_nodr9['DEC'], s=50) ; plt.savefig('junk.png')
    
        nsa = nsa[indx_nsa]
        print(f'Writing {nsadr9file}')
        nsa.write(nsadr9file, overwrite=True)

        print(f'Writing {nsanodr9file}')
        nsa_nodr9.write(nsanodr9file, overwrite=True)

        pngfile = os.path.join(paperdir, 'data', 'nsa', 'qa-nsa-dr9-radec.png')
        print('Writing {}'.format(pngfile))
        fig, ax = plt.subplots(figsize=(10, 7))
        ax.scatter(sga['RA'], sga['DEC'], s=1, label='SGA')
        ax.scatter(nsa['RA'], nsa['DEC'], s=1, marker='s', alpha=0.5, label='NSA-DR9')
        ax.scatter(nsa_nodr9['RA'], nsa_nodr9['DEC'], s=10, marker='s', label='NSA - outside DR9')
        ax.set_xlabel('RA (degree)')
        ax.set_ylabel('Dec (degree)')
        ax.legend(fontsize=12)
        fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    nsa = Table(fitsio.read(nsadr9file, columns=['NSAID', 'IAUNAME', 'RA', 'DEC', 'Z', 
                                                 #'PETROTHETA', 'PETROTH50', 'PETROTH90', 
                                                 'SERSIC_TH50', 'SERSIC_BA', 'SERSIC_PHI', 'SERSIC_FLUX', 
                                                 'ELPETRO_FLUX_R', 'ELPETRO_BA', 'ELPETRO_PHI', 'ELPETRO_TH50_R'
                                                 ]))
    print('Read {} galaxies from {}'.format(len(nsa), nsadr9file))

    I = np.where(np.logical_or(nsa['ELPETRO_TH50_R'] < 0, nsa['ELPETRO_BA'] < 0))[0]
    nsa['ELPETRO_TH50_R'][I] = nsa['SERSIC_TH50'][I]
    nsa['ELPETRO_BA'][I] = nsa['SERSIC_BA'][I]
    nsa['ELPETRO_PHI'][I] = nsa['SERSIC_PHI'][I]
    nsa['ELPETRO_FLUX_R'][I] = nsa['SERSIC_FLUX'][I, 2]

    # testing stuff
    nsa_nodr9 = Table(fitsio.read(nsanodr9file, columns=['NSAID', 'IAUNAME', 'RA', 'DEC', 'Z']))
    print('Read {} galaxies from {}'.format(len(nsa_nodr9), nsanodr9file))

    # quick QA to determine the matching radius
    c_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
    c_nsa = SkyCoord(ra=nsa['RA']*u.deg, dec=nsa['DEC']*u.deg)
    _, sep2d, _ = c_nsa.match_to_catalog_sky(c_sga)

    pngfile = os.path.join(paperdir, 'data', 'nsa', 'qa-nsa-sga2020-separation.png')
    print('Writing {}'.format(pngfile))
    fig, ax = plt.subplots(figsize=(10, 7))
    sep2d = sep2d.arcsec
    #sep2d[sep2d < 1e-1] = 1e-1
    #_ = ax.hist(sep2d, bins=100, cumulative=True, density=True, histtype='step')
    _ = ax.hist(np.log10(sep2d), bins=75, label='All Galaxies')#, cumulative=True, density=True, histtype='step')
    _ = ax.hist(np.log10(sep2d[nsa['ELPETRO_TH50_R']>30]), bins=75, label=r'$r_{50,EllPetro}>30$ arcsec')
    ax.axvline(x=np.log10(10), ls='--', color='k')
    ax.set_xlabel(r'$\log_{10}\,(\mathrm{NSA-SGA\ Separation})$ (arcsec)')
    ax.set_ylabel('Number of Galaxies')
    #ax.set_yscale('log')
    ax.legend(fontsize=14)
    #ax.set_xlim(0, 100)
    #ax.axvline(x=rad.value, ls='-', color='k')
    fig.subplots_adjust(bottom=0.14, right=0.95, top=0.95, left=0.17)
    fig.savefig(pngfile)#, bbox_inches='tight')
    plt.close(fig)

    #nsa[nsa['ELPETRO_TH50_R'] < 0]
    #plt.clf() ; plt.scatter(np.log10(nsa['ELPETRO_TH50_R']/60), np.log10(sep2d), s=1) ; plt.savefig('junk.png')

    # now match
    if True:
        from pydl.pydlutils.spheregroup import spherematch
        rad = 10.0
        indx_nsa, indx_sga, sep = spherematch(nsa['RA'], nsa['DEC'], sga['RA'], sga['DEC'], rad/3600., maxmatch=1)
    else:
        rad = 10 * u.arcsec
        indx_nsa, indx_sga, d2d, _ = c_sga.search_around_sky(c_nsa, rad)
        indx_nsa, indx_sga, d2d, _ = c_sga.search_around_sky(c_nsa, rad)
        print(len(indx_nsa), len(np.unique(indx_nsa)))
    print('Found {:,d}/{:,d} unique SGA-NSA matches within {} arcsec.'.format(len(indx_nsa), len(nsa), rad))
    assert(len(indx_nsa) == len(np.unique(indx_nsa)))

    m_sga = sga[indx_sga]
    m_nsa = nsa[indx_nsa]

    # find the median scaling between D25_LEDA and PETROTHETA
    sersicfactor = np.median(60*m_sga['D25_LEDA'] / m_nsa['ELPETRO_TH50_R'])
    print('Median NSA(D25) = {:.4f} x ELPETRO_TH50_R'.format(sersicfactor))
    sersicfactor = 5.0

    #plt.clf() ; _=plt.hist(m_sga['D25_LEDA']/(m_nsa['ELPETRO_TH50_R']/60), bins=100, range=(0, 20)) ; plt.axvline(x=sersicfactor, color='k') ; plt.xlim(0, 20) ; plt.savefig('junk.png')
    #plt.clf() ; plt.scatter(m_sga['D25_LEDA'], m_sga['D25_LEDA']/(m_nsa['ELPETRO_TH50_R']/60), s=1) ; plt.axhline(y=sersicfactor, color='k') ;  plt.ylim(2, 10) ; plt.savefig('junk.png')

    # get the raw and corrected fraction of non-matches as a function of SERSIC_TH50
    lograd = np.log10(sersicfactor*nsa['ELPETRO_TH50_R']/60)
    match_lograd = np.log10(sersicfactor*m_nsa['ELPETRO_TH50_R']/60)
    minrad, maxrad, drad = -1.4, 1.3, 0.1
    ##minrad, maxrad = np.min(lograd), np.max(lograd)

    nhist = int(np.ceil((maxrad - minrad) / drad))
    histobins = np.histogram_bin_edges(match_lograd, bins=nhist, range=(minrad, maxrad))
    histobins = np.array([-1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4,
                          -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,
                          0.8,  0.9,  1. ,  1.1,  1.2,  1.3])
    bins = histobins[:-1]

    #bins = np.arange(minrad, maxrad, drad) # bin left edges
    numer, _ = np.histogram(match_lograd, bins=histobins)
    denom, _ = np.histogram(lograd, bins=histobins)
    #denom, _ = np.histogram(lograd, bins=len(bins), range=(minrad, maxrad+drad))

    good = denom > 0
    xfrac = bins[good]
    yfrac = numer[good] / denom[good] 
    for ii, (bb, nn, dd) in enumerate(zip(bins, numer, denom)):
        print(bb, 10**bb, nn, dd, nn/dd, dd-nn) # np.sum((lograd>bb)*(lograd<(bb+drad))))

    _logradcut = 0.0
    I = bins >= _logradcut
    print('There are {} NSA galaxies not in the SGA larger than {:.1f} arcmin.'.format(
        np.sum(denom[I]-numer[I]), 10**_logradcut))

    # --------------------------------------------------
    # NSA galaxies not in the SGA
    remake_montage = True
    if remake_montage:
        nsa_notin_sga = nsa[np.delete(np.arange(len(nsa)), indx_nsa)]

        srt = np.argsort(nsa_notin_sga['ELPETRO_TH50_R'])[::-1]
        nsa_notin_sga = nsa_notin_sga[srt]
        
        #I = np.log10(sersicfactor * nsa_notin_sga['ELPETRO_TH50_R'] / 60) >= logradcut
        #print('Trimming to {:,d}/{:,d} NSA galaxies with 4.5xSERSIC_TH50>{:.1f} arcmin not in the SGA'.format(
        #    np.sum(I), len(nsa_notin_sga), 10**logradcut))
        #nsa_notin_sga = nsa_notin_sga[I]
        #srt = np.argsort(nsa_notin_sga['ELPETRO_TH50_R'])[::-1]
        #nsa_notin_sga = nsa_notin_sga[srt]
        #print(nsa_notin_sga)
    
        montagedir = os.path.join(paperdir, 'data', 'nsa', 'nsa-notin-sga')
        if not os.path.isdir(montagedir):
            os.makedirs(montagedir, exist_ok=True)
        
        ncol = 10
        nrow = 10
        ngal = ncol * nrow
    
        pixscale = 5.0 # 0.262
        barlen = np.ceil(60 / pixscale) # [pixels]
        barlabel = '' # '30 arcsec'

        logradcut = 1.0

        # split into diameter bins
        for ibin in np.arange(len(bins)):
            minbin, maxbin = histobins[ibin], histobins[ibin+1]
            print(ibin, minbin, maxbin)
            if minbin < logradcut:
                continue

            binlabel = '{:.1f}-{:.1f}arcmin'.format(10**minbin, 10**maxbin)

            dnsa = np.log10(sersicfactor * nsa_notin_sga['ELPETRO_TH50_R'] / 60)
            B = np.where((dnsa >= minbin) * (dnsa < maxbin))[0]

            nsa_notin_sga_bin = nsa_notin_sga[B]

            # find near SGA sources, if any
            coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)
            coord_nsa_notin_sga = SkyCoord(ra=nsa_notin_sga_bin['RA']*u.deg, dec=nsa_notin_sga_bin['DEC']*u.deg)
        
            # split into multiple pages
            Isplit = np.array_split(np.arange(len(nsa_notin_sga_bin)), np.ceil(len(nsa_notin_sga_bin)/ngal).astype(int))
            npage = len(Isplit)
            print(f'Splitting into {npage} pages with {ngal} galaxies per page.')

            for ipage, I in enumerate(Isplit):
                print('Working on page {}/{} with {} galaxies.'.format(ipage+1, npage, len(I)))

                sga_close = []
                for coord_nsa_notin_sga1, diam in zip(coord_nsa_notin_sga[I], sersicfactor*nsa_notin_sga_bin['ELPETRO_TH50_R'][I]):
                    sep = coord_nsa_notin_sga1.separation(coord_sga)
                    close = sep.arcsec < 2*diam
                    if np.any(close):
                        sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
                    else:
                        sga_close.append(Table())

                pngfiles = []
                for onegal, onesga in zip(nsa_notin_sga_bin[I], sga_close):
                    jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['NSAID']))
                    width = int(2 * sersicfactor * onegal['ELPETRO_TH50_R'] / pixscale)
                    if not os.path.isfile(jpgfile):
                        urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                            onegal['RA'], onegal['DEC'], pixscale, width, width)
                        cmd = f'wget -q -O {jpgfile} {urlfile}'
                        print(cmd)
                        subprocess.call(cmd.split())
            
                    pngfile1 = jpgfile.replace('.jpg', '.png')
                    if not os.path.isfile(pngfile1):
                        with Image.open(jpgfile) as colorimg:
                            imgsz = colorimg.size
            
                            hdr = fits.Header()
                            hdr['NAXIS'] = 2
                            hdr['NAXIS1'] = imgsz[0]
                            hdr['NAXIS2'] = imgsz[0]
                            hdr['CTYPE1'] = 'RA---TAN'
                            hdr['CTYPE2'] = 'DEC--TAN'
                            hdr['CRVAL1'] = onegal['RA']
                            hdr['CRVAL2'] = onegal['DEC']
                            hdr['CRPIX1'] = imgsz[0]/2+0.5
                            hdr['CRPIX2'] = imgsz[0]/2+0.5
                            hdr['CD1_1'] = -pixscale/3600
                            hdr['CD1_2'] = 0.0
                            hdr['CD2_1'] = 0.0
                            hdr['CD2_2'] = +pixscale/3600
                            wcs = WCS(hdr)
                    
                            try:
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['ELPETRO_BA'], 
                                                    onegal['ELPETRO_PHI'], sersicfactor*onegal['ELPETRO_TH50_R'], 
                                                    pixscale, color='red', linewidth=2)
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['ELPETRO_BA'], 
                                                    onegal['ELPETRO_PHI'], 2*onegal['ELPETRO_TH50_R'], 
                                                    pixscale, color='red', linewidth=2)
                            except:
                                pdb.set_trace()

                            # add the SGA sources, if any
                            if len(onesga) > 0:
                                for onesga1 in onesga:
                                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                                        color='dodgerblue', linewidth=2)
            
                            print(f'Writing {pngfile1}')
                            colorimg.save(pngfile1)
            
                        label = 'NSA ID: {}'.format(onegal['NSAID'].astype(str))
                        addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
                        #pdb.set_trace()
            
                    pngfiles.append(pngfile1)
            
                pngfile = os.path.join(paperdir, 'data', 'nsa', 'nsa-notin-sga-{}-{:02d}.png'.format(binlabel, ipage))
                print('Writing {}'.format(pngfile))
            
                cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 256x256 '.format(ncol, nrow)
                cmd = cmd+' '.join([pngf for pngf in pngfiles])
                cmd = cmd+' {}'.format(pngfile)
                print(cmd)
                os.system(cmd)        
    
                pdb.set_trace()
    # --------------------------------------------------

    # make the QA -
    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        elif (x < 0) and (x >= -1):
            return '{:.1f}'.format(10**x)
        else:
            return '{:.2f}'.format(10**x)

    fig, ax = plt.subplots(figsize=(10, 7))

    xlim = (minrad, maxrad)
    ylim = (6.5, 26)
    I = np.where((nsa['ELPETRO_TH50_R'] > 0) * (nsa['ELPETRO_FLUX_R'] > 0))[0]
    corner.hist2d(np.log10(sersicfactor*nsa['ELPETRO_TH50_R'][I]/60), 
                  22.5-2.5*np.log10(nsa['ELPETRO_FLUX_R'][I]), 
                  levels=[0.1, 0.25, 0.5, 0.75, 0.95, 0.99],
                  #levels=[0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                  bins=75, smooth=True, ax=ax, color='k', #mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': 'k', 'alpha': 1.0, 'ms': 3, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k', 'alpha': 0.5}
                 )
    #ax.scatter(np.log10(m_nsa['ELPETRO_TH50_R']), m_nsa['BT'], s=1, color='red')
    #ax.scatter(np.log10(miss_nsa['ELPETRO_TH50_R']), miss_nsa['BT'], s=10, color=colors[2], marker='s', alpha=1)

    ax.set_xlabel(r'$\log_{10}\,(5\times r_{50,\mathrm{ElPetro}})$ [NSA, arcmin]')
    ax.set_ylabel(r'$m_{r,\mathrm{ElPetro}}$ [NSA]')
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(2))
    ax.xaxis.set_major_formatter(major_formatter)
    ax.set_xticks(np.log10([0.05, 0.2, 0.5, 1, 2, 5, 10, 19]))
    
    ax2 = ax.twinx()
    #for bb in bins:
    #    ax2.axvline(x=bb, color='orange', ls='-', alpha=1)
    ax2.axvline(x=np.log10(20/60), color=colors[2], ls='--', alpha=1)
    #ax2.axvline(x=np.log10(30/60), color=colors[0], ls='--', alpha=1)
    ax2.axhline(y=1.0, ls='--', lw=2, color=colors[2], alpha=1)
    ax2.step(xfrac+drad, yfrac, color=colors[3], ls='-', lw=3, where='pre')
    ax2.set_ylim(0, 1.05)
    ax2.set_ylabel('Fraction of SGA-NSA Matches')

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.subplots_adjust(bottom=0.14, right=0.85)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def fig_hecate_completeness(sga, png=None):
    """Quantify the sample completeness by comparing against HECATE."""

    import corner
    from glob import glob
    import astropy.units as u
    from astropy.table import vstack
    from astropy.coordinates import SkyCoord, match_coordinates_sky
    from PIL import Image, ImageDraw
    from astropy.io import fits
    from astropy.wcs import WCS
    from legacyhalos.qa import draw_ellipse_on_png, addbar_to_png

    sns, colors = plot_style(talk=True, font_scale=1.3)

    # Find the subset of HECATE targets which have grz imaging from DR9.
    hecatefile = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.fits')
    hecatedr9file = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.dr9.fits')
    hecatenodr9file = os.path.join(paperdir, 'data', 'hecate', 'HECATE_v1.1.nodr9.fits')
    if not os.path.isfile(hecatedr9file):
        hecate = Table(fitsio.read(hecatefile, ext=1))
        print('Read {} objects from {}'.format(len(hecate), hecatefile))

        ## match to the MW dwarf catalog, which we will handle below
        #dwarffile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'SGA-dwarfs.fits')
        #print('Reading {}'.format(dwarffile))
        #dwarfs = Table(fitsio.read(dwarffile))
        #
        #c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        #c_dwarfs = SkyCoord(dwarfs['RA']*u.deg, dwarfs['DEC']*u.deg)
        #
        #indx_hecate, indx_dwarfs, d2d, _ = c_dwarfs.search_around_sky(c_hecate, 120*u.arcsec)
        #miss_dwarfs = dwarfs[np.delete(np.arange(len(dwarfs)), indx_dwarfs)]
        #print('Note: HECATE is missing {}/{} of the MW Dwarfs from McConnachie+2012 within 1 arcmin'.format(len(miss_dwarfs), len(dwarfs)))

        #_, sep2d, _ = c_hecate.match_to_catalog_sky(c_dwarfs)
        #pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-mwdwarfs-separation.png')
        #print('Writing {}'.format(pngfile))
        #fig, ax = plt.subplots(figsize=(10, 7))    
        #_ = ax.hist(sep2d.arcmin, bins=100)#, range=(0, 30))
        #fig.savefig(pngfile)#, bbox_inches='tight')

        randomfiles = glob(os.path.join(paperdir, 'data', 'randoms-1-*.fits'))
        rand = []
        for randomfile in randomfiles:
            print('Reading {}'.format(randomfile))
            rand1 = fitsio.read(randomfile, columns=['NOBS_G', 'NOBS_R', 'NOBS_Z'])
            I = np.where((rand1['NOBS_G'] > 0) * (rand1['NOBS_R'] > 0) * (rand1['NOBS_Z'] > 0))[0]
            rand.append(Table(fitsio.read(randomfile, columns=['RA', 'DEC'], rows=I)))
        rand = vstack(rand)
        print('Read {:,d} random points from {} randomfiles.'.format(len(rand), len(randomfiles)))

        c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        idx, d2d, _ = c_hecate.match_to_catalog_sky(c_rand)

        c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        c_rand = SkyCoord(rand['RA']*u.deg, rand['DEC']*u.deg)
        rad = 2 * u.arcmin
        _, indx_hecate, d2d, _ = c_hecate.search_around_sky(c_rand, rad)
        indx_hecate = np.sort(np.unique(indx_hecate))
        print('Matched {}/{} HECATE galaxies to a DR9 random point with NOBS_[GRZ]>1'.format(len(indx_hecate), len(hecate)))
    
        hecate_nodr9 = hecate[np.delete(np.arange(len(hecate)), indx_hecate)]

        hecate = hecate[indx_hecate]
        print(f'Writing {hecatedr9file}')
        hecate.write(hecatedr9file, overwrite=True)

        print(f'Writing {hecatenodr9file}')
        hecate_nodr9.write(hecatenodr9file, overwrite=True)

        pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-dr9-radec.png')
        print('Writing {}'.format(pngfile))
        fig, ax = plt.subplots(figsize=(10, 7))
        ax.scatter(sga['RA'], sga['DEC'], s=1, label='SGA')
        ax.scatter(hecate['RA'], hecate['DEC'], s=1, marker='s', alpha=0.5, label='HECATE-DR9')
        ax.scatter(hecate_nodr9['RA'], hecate_nodr9['DEC'], s=1, marker='s', label='HECATE - outside DR9')
        ax.set_xlabel('RA (degree)')
        ax.set_ylabel('Dec (degree)')
        ax.legend(fontsize=12)
        fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

    # read the previously created matched catalog
    hecate = Table(fitsio.read(hecatedr9file, ext=1))
    print('Read {} objects from {}'.format(len(hecate), hecatedr9file))

    keep = np.where(np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    print('Removing {} HECATE objects with no diameters.'.format(len(hecate)-len(keep)))
    #keep = np.where(np.isfinite(hecate['BT']) * np.isfinite(hecate['R1']) * np.isfinite(hecate['R2']))[0]
    #print('Removing {} HECATE objects with no diameters or magnitudes estimate.'.format(len(hecate)-len(keep)))
    hecate = hecate[keep]
    hecate['BA'] = hecate['R2'] / hecate['R1']

    if False:
        # Remove the Local Group Dwarfs which were intentionally excluded from the
        # sample, plus Fornax and Sculptor.
        dwarffile = os.path.join(os.getenv('LEGACYHALOS_DIR'), 'sample', 'catalogs', 'SGA-dwarfs.fits')
        print('Reading {}'.format(dwarffile))
        dwarfs = Table(fitsio.read(dwarffile))
        dwarfs = dwarfs[np.logical_or(dwarfs['RESOLVED'], dwarfs['IGNORE'])]
    
        #c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
        #c_dwarfs = SkyCoord(dwarfs['RA']*u.deg, dwarfs['DEC']*u.deg)
    
        #_, sep2d, _ = c_hecate.match_to_catalog_sky(c_dwarfs)
        #pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-mwdwarfs-separation.png')
        #print('Writing {}'.format(pngfile))
        #fig, ax = plt.subplots(figsize=(10, 7))    
        #_ = ax.hist(sep2d.arcmin, bins=100)#, range=(0, 30))
        #fig.savefig(pngfile)#, bbox_inches='tight')
    
        #indx_hecate, indx_dwarfs, d2d, _ = c_dwarfs.search_around_sky(c_hecate, 120*u.arcsec)
        dwarfpgc = {
            'SagittariusdSph': 4689212,
            'SegueI': 4713559,
            'UrsaMajorII': 4713555,
            'BootesII': 4713552,
            'SegueII': 4713565,
            'Willman1': 4713556,
            'BootesI': 4713553,
            'Draco': 60095,
            'UrsaMinor': 54074,
            'SextansI': 88608,
            'UrsaMajorI': 4713554,
            'Hercules': 4713560,
            'LeoIV': 4713561,
            'LeoV': 4713563,
            'PiscesII': 5056949,
            'CanesVenaticiI': 4689223,
            'AndromedaXIV': 5056922,
            'AndromedaXIII': 5056925,
            'AndromedaII': 4601,
            'AndromedaXXIX': 5060430,
            'AndromedaXXII': 5057232,
            'AndromedaXVI': 5056927,
            'LeoT': 4713564,
            'ComaBerenices': -1, 
            'CanesVenaticiII': 4713558,
            'AndromedaXX': 5056920,
            'Antlia': 29194,
            'Carina': 19441,
            'AndromedaX': 5056921,
            'AndromedaIX': 4689222,
            'AndromedaXVII': 4608690,
            'AndromedaXXVII': 5057230,
            'AndromedaXXV': 5057228,
            'AndromedaI': 2666,
            'AndromedaIII': 2121,
            'AndromedaXV': 5056926,
            'AndromedaXII': 5056924,
            'AndromedaXI': 5056923,
            'AndromedaXXVI': 5057229,
            'AndromedaXIX': 5056919,
            'AndromedaXXI': 5057231,
            'AndromedaXVIII': 5056918,
            'AndromedaXXIV': 5057227,
            'AndromedaXXIII': 5057226,
            'AndromedaV': 3097824,
            'AndromedaVII': 2807155,
            'Aquarius': 65367,
            'Sculptor': 3589,
            'Fornax': 10074,
            }
    
        #J = np.where(sga['GALAXY'] == thisdwarf)[0]
        #if len(J) == 1:
        #    sga['PGC'][J] = dwarfpgc[thisdwarf]
        for thisdwarf in dwarfpgc.keys():
            I = np.where(dwarfs['GALAXY'] == thisdwarf)[0]
            dwarfs['PGC'][I] = dwarfpgc[thisdwarf]
    
        indx_dwarfs, indx_hecate, miss_dwarfs = [], [], []
        for I, pgc in enumerate(dwarfs['PGC']):
            J = np.where(hecate['PGC'] == pgc)[0]
            if len(J) == 1:
                indx_dwarfs.append(I)
                indx_hecate.append(J)
            else:
                miss_dwarfs.append(dwarfs[I])
                
        indx_dwarfs = np.hstack(indx_dwarfs)
        indx_hecate = np.hstack(indx_hecate)
        miss_dwarfs = vstack(miss_dwarfs)
    
        c_hecate = SkyCoord(hecate[indx_hecate]['RA']*u.deg, hecate[indx_hecate]['DEC']*u.deg)
        c_dwarfs = SkyCoord(dwarfs[indx_dwarfs]['RA']*u.deg, dwarfs[indx_dwarfs]['DEC']*u.deg)
        _, sep2d, _ = c_hecate.match_to_catalog_sky(c_dwarfs)
        print('Mean, min, max delta-theta between McConnachie+12 and HECATE coordinates={:.4f}, {:.4f}, {:.4f} arcsec'.format(
            np.mean(sep2d.arcsec), np.min(sep2d.arcsec), np.max(sep2d.arcsec)))
    
        keep_hecate = np.delete(np.arange(len(hecate)), indx_hecate)
        print('Removing {}/{} HECATE objects which are MW dwarfs intentionally excluded from the SGA.'.format(len(indx_hecate), len(hecate)))
        hecate = hecate[keep_hecate]

    # Match the catalogs, first by PGC.
    dwarfpgc = {
        'SagittariusdSph': 4689212,
        'SegueI': 4713559,
        'UrsaMajorII': 4713555,
        'BootesII': 4713552,
        'SegueII': 4713565,
        'Willman1': 4713556,
        'BootesI': 4713553,
        'Draco': 60095,
        'UrsaMinor': 54074,
        'SextansI': 88608,
        'UrsaMajorI': 4713554,
        'Hercules': 4713560,
        'LeoIV': 4713561,
        'LeoV': 4713563,
        'PiscesII': 5056949,
        'CanesVenaticiI': 4689223,
        'AndromedaXIV': 5056922,
        'AndromedaXIII': 5056925,
        'AndromedaII': 4601,
        'AndromedaXXIX': 5060430,
        'AndromedaXXII': 5057232,
        'AndromedaXVI': 5056927,
        'LeoT': 4713564,
        'ComaBerenices': -1, 
        'CanesVenaticiII': 4713558,
        'AndromedaXX': 5056920,
        'Antlia': 29194,
        'Carina': 19441,
        'AndromedaX': 5056921,
        'AndromedaIX': 4689222,
        'AndromedaXVII': 4608690,
        'AndromedaXXVII': 5057230,
        'AndromedaXXV': 5057228,
        'AndromedaI': 2666,
        'AndromedaIII': 2121,
        'AndromedaXV': 5056926,
        'AndromedaXII': 5056924,
        'AndromedaXI': 5056923,
        'AndromedaXXVI': 5057229,
        'AndromedaXIX': 5056919,
        'AndromedaXXI': 5057231,
        'AndromedaXVIII': 5056918,
        'AndromedaXXIV': 5057227,
        'AndromedaXXIII': 5057226,
        'AndromedaV': 3097824,
        'AndromedaVII': 2807155,
        'Aquarius': 65367,
        'Sculptor': 3589,
        'Fornax': 10074,
        # 
        'AndromedaVI': 2807158,
        'AndromedaXXVIII': 5060429,
        }
    for thisdwarf in dwarfpgc.keys():
        I = np.where(sga['GALAXY'] == thisdwarf)[0]
        if len(I) == 1:
            #print(f'Matching {thisdwarf}')
            sga['PGC'][I] = dwarfpgc[thisdwarf]

    indx_sga, indx_hecate = [], []
    for I, pgc in enumerate(hecate['PGC']):
        J = np.where(pgc == sga['PGC'])[0]
        #if pgc == 70761:
        #    pdb.set_trace()
        if len(J) > 1:
            pdb.set_trace()
        if len(J) == 1:
            indx_hecate.append(I)
            indx_sga.append(J)
    indx_hecate = np.hstack(indx_hecate)
    indx_sga = np.hstack(indx_sga)
    print('Matched {}/{} HECATE galaxies to the SGA based on PGC number.'.format(len(indx_hecate), len(hecate)))

    # classify

    #LAMOSTJ124211.85+323232.3.png
    #pdb.set_trace()

    m_sga = sga[indx_sga]
    m_hecate = hecate[indx_hecate]

    miss_sga = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
    miss_hecate = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]

    # quick QA of the separation for PGC-matched and PGC-non-matched galaxies
    c_m_hecate = SkyCoord(m_hecate['RA']*u.deg, m_hecate['DEC']*u.deg)
    c_m_sga = SkyCoord(m_sga['RA']*u.deg, m_sga['DEC']*u.deg)
    _, m_sep2d, _ = c_m_hecate.match_to_catalog_sky(c_m_sga)
    
    c_miss_hecate = SkyCoord(miss_hecate['RA']*u.deg, miss_hecate['DEC']*u.deg)
    c_miss_sga = SkyCoord(miss_sga['RA']*u.deg, miss_sga['DEC']*u.deg)
    _, miss_sep2d, _ = c_miss_hecate.match_to_catalog_sky(c_miss_sga)
    
    pngfile = os.path.join(paperdir, 'data', 'hecate', 'qa-hecate-sga2020-separation.png')
    print('Writing {}'.format(pngfile))
    fig, ax = plt.subplots(figsize=(10, 7))
    _ = ax.hist(np.log10(m_sep2d.arcsec), bins=75, label='PGC-matched')
    _ = ax.hist(np.log10(miss_sep2d.arcsec), bins=75, alpha=0.5, label='PGC not-matched')
    ax.set_xlabel(r'$\log_{10}\,(\mathrm{HECATE-SGA\ Separation})$ (arcsec)')
    ax.set_ylabel('Number of Galaxies')
    ax.set_yscale('log')
    ax.axvline(x=np.log10(10), ls='--', color='k')
    ax.legend(fontsize=14)
    fig.subplots_adjust(bottom=0.15, right=0.95, top=0.95, left=0.17)
    fig.savefig(pngfile)#, bbox_inches='tight')
    plt.close(fig)

    if False:
        # match the catalogs
        c_sga = SkyCoord(sga['RA']*u.deg, sga['DEC']*u.deg)    
        #c_sga = SkyCoord(sga['RA_LEDA']*u.deg, sga['DEC_LEDA']*u.deg)    
        c_hecate = SkyCoord(hecate['RA']*u.deg, hecate['DEC']*u.deg)
    
        if True:
            from pydl.pydlutils.spheregroup import spherematch
            rad = 10.0
            indx_hecate, indx_sga, sep = spherematch(hecate['RA'], hecate['DEC'], sga['RA'], sga['DEC'], rad/3600., maxmatch=1)
        else:
            rad = 10 * u.arcsec
            indx_hecate, indx_sga, d2d, _ = c_sga.search_around_sky(c_hecate, rad)
        print('Found {:,d}/{:,d} unique SGA-HECATE matches within {} arcsec.'.format(len(indx_hecate), len(hecate), rad))
        assert(len(indx_hecate) == len(np.unique(indx_hecate)))
    
        # match on PGC number
        sga['PGC'][sga['GALAXY'] == 'AndromedaVI'] = 2807158
        sga['PGC'][sga['GALAXY'] == 'AndromedaXXVIII'] = 5060429
    
        m_sga = sga[indx_sga]
        m_hecate = hecate[indx_hecate]
    
        pdb.set_trace()    
    
        #miss_sga = sga[np.delete(np.arange(len(sga)), indx_sga)]
        #miss_hecate = hecate[np.delete(np.arange(len(hecate)), indx_hecate)]
        miss_sga = sga[~np.isin(sga['SGA_ID'], m_sga['SGA_ID'])]
        miss_hecate = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]
    
        supp_sga, supp_hecate = [], []
        for I, pgc in enumerate(miss_hecate['PGC']):
            J = np.where(pgc == miss_sga['PGC'])[0]
            #if pgc == 70761:
            #    pdb.set_trace()
            if len(J) == 1:
                supp_hecate.append(I)
                supp_sga.append(J)
        supp_hecate = np.hstack(supp_hecate)
        supp_sga = np.hstack(supp_sga)
        print('Matching an additional {}/{} SGA sources to HECATE based on PGC number.'.format(len(supp_hecate), len(miss_hecate)))
    
        c_supp_hecate = SkyCoord(miss_hecate[supp_hecate]['RA']*u.deg, miss_hecate[supp_hecate]['DEC']*u.deg)
        c_supp_sga = SkyCoord(miss_sga[supp_sga]['RA']*u.deg, miss_sga[supp_sga]['DEC']*u.deg)
        _, sep2d, _ = c_supp_hecate.match_to_catalog_sky(c_supp_sga)
        print('Mean, min, max delta-theta between SGA and HECATE coordinates for the PGC matches={:.4f}, {:.4f}, {:.4f} arcsec.'.format(
            np.mean(sep2d.arcsec), np.min(sep2d.arcsec), np.max(sep2d.arcsec)))
    
        print('Galaxies where the SGA-HECATE coordinates differ by >10 arcsec:')
        print(miss_hecate[supp_hecate][sep2d.arcsec > 10]['OBJNAME', 'ID_NED', 'RA', 'DEC', 'R1', 'PGC'])
    
        m_sga = vstack((m_sga, miss_sga[supp_sga]))
        m_hecate = vstack((m_hecate, miss_hecate[supp_hecate]))
        print('Final sample: {}/{} ({:.2f}%) HECATE-SGA matches.'.format(len(m_hecate), len(hecate), 100*len(m_hecate)/len(hecate)))
    
    # get the raw and corrected fraction of non-matches as a function of SERSIC_TH50
    lograd = np.log10(2*hecate['R1'])
    match_lograd = np.log10(2*m_hecate['R1'])
    minrad, maxrad, drad = -1.4, 1.2, 0.2
    ##minrad, maxrad = np.min(lograd), np.max(lograd)

    nhist = int(np.ceil((maxrad - minrad) / drad))
    histobins = np.histogram_bin_edges(match_lograd, bins=nhist, range=(minrad, maxrad))
    histobins = np.array([-1.4, -1.2, -1. , -0.8, -0.6, -0.4,
                          -0.2, 0., 0.2, 0.4, 0.6, 0.8, 1., 1.2])
    #histobins = np.array([-1.4, -1.3, -1.2, -1.1, -1. , -0.9, -0.8, -0.7, -0.6, -0.5, -0.4,
    #                      -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,
    #                      0.8,  0.9,  1. ,  1.1,  1.2,  1.3])
    bins = histobins[:-1]

    #bins = np.arange(minrad, maxrad, drad) # bin left edges
    numer, _ = np.histogram(match_lograd, bins=histobins)
    denom, _ = np.histogram(lograd, bins=histobins)
    #denom, _ = np.histogram(lograd, bins=len(bins), range=(minrad, maxrad+drad))

    good = denom > 0
    xfrac = bins[good]
    yfrac = numer[good] / denom[good] 
    for ii, (bb, nn, dd) in enumerate(zip(bins, numer, denom)):
        print(bb, 10**bb, nn, dd, nn/dd, dd-nn) # np.sum((lograd>bb)*(lograd<(bb+drad))))

    _logradcut = 0.0
    I = bins >= _logradcut
    print('There are {} HECATE galaxies not in the SGA larger than {:.1f} arcmin.'.format(
        np.sum(denom[I]-numer[I]), 10**_logradcut))

    # --------------------------------------------------
    # HECATE galaxies not in the SGA
    remake_montage = True
    if remake_montage:
        hecate_notin_sga = hecate[~np.isin(hecate['PGC'], m_hecate['PGC'])]
        #hecate_notin_sga = hecate[np.delete(np.arange(len(hecate)), indx_hecate)]

        srt = np.argsort(hecate_notin_sga['R1'])[::-1]
        hecate_notin_sga = hecate_notin_sga[srt]

        #pdb.set_trace()

        montagedir = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga')
        if not os.path.isdir(montagedir):
            os.makedirs(montagedir, exist_ok=True)
        
        pixscale = 1.0 # 0.262
        barlen = np.ceil(60 / pixscale) # [pixels]
        barlabel = '' # '30 arcsec'

        logradcut = 0.2

        coord_sga = SkyCoord(ra=sga['RA']*u.deg, dec=sga['DEC']*u.deg)

        # split into diameter bins
        for ibin in np.arange(len(bins)):
            minbin, maxbin = histobins[ibin], histobins[ibin+1]
            print(ibin, minbin, maxbin)
            if minbin < logradcut:
                continue

            binlabel = '{:.1f}-{:.1f}arcmin'.format(10**minbin, 10**maxbin)

            dhecate = np.log10(2 * hecate_notin_sga['R1'])
            B = np.where((dhecate >= minbin) * (dhecate < maxbin))[0]
            if len(B) == 0:
                pdb.set_trace()

            if len(B) >= 100:
                ncol, nrow = 10, 10
            elif len(B) >= 49 and len(B) < 100:
                ncol, nrow = 7, 7
            elif len(B) >= 25 and len(B) < 49:
                ncol, nrow = 5, 5
            else:
                ncol, nrow = 4, 4

            ngal = ncol * nrow

            hecate_notin_sga_bin = hecate_notin_sga[B]

            # find near SGA sources, if any
            coord_hecate_notin_sga = SkyCoord(ra=hecate_notin_sga_bin['RA']*u.deg, dec=hecate_notin_sga_bin['DEC']*u.deg)
        
            # split into multiple pages
            Isplit = np.array_split(np.arange(len(hecate_notin_sga_bin)), np.ceil(len(hecate_notin_sga_bin)/ngal).astype(int))
            npage = len(Isplit)
            print(f'Splitting into {npage} pages with {ngal} galaxies per page.')

            for ipage, I in enumerate(Isplit):
                print('Working on page {}/{} with {} galaxies.'.format(ipage+1, npage, len(I)))

                sga_close = []
                for coord_hecate_notin_sga1, diam in zip(coord_hecate_notin_sga[I], 2*60*hecate_notin_sga_bin['R1'][I]):
                    sep = coord_hecate_notin_sga1.separation(coord_sga)
                    close = sep.arcsec < 2*diam
                    if np.any(close):
                        sga_close.append(vstack(sga[close]['GALAXY', 'RA', 'DEC', 'D26', 'PA', 'BA']))
                    else:
                        sga_close.append(Table())

                pngfiles = []
                for onegal, onesga in zip(hecate_notin_sga_bin[I], sga_close):
                    #pdb.set_trace()
                    jpgfile = os.path.join(montagedir, '{}.jpg'.format(onegal['OBJNAME']))
                    width = int(2.5 * 2*onegal['R1']*60 / pixscale)
                    if width == 0:
                        pdb.set_trace()

                    if not os.path.isfile(jpgfile):
                        urlfile = jpgurl+'ra={}&dec={}&pixscale={}&width={}&height={}&layer=ls-dr9'.format(
                            onegal['RA'], onegal['DEC'], pixscale, width, width)
                        cmd = f'wget -q -O {jpgfile} {urlfile}'
                        print(cmd)
                        subprocess.call(cmd.split())
            
                    pngfile1 = jpgfile.replace('.jpg', '.png')
                    if not os.path.isfile(pngfile1):
                        with Image.open(jpgfile) as colorimg:
                            imgsz = colorimg.size
            
                            hdr = fits.Header()
                            hdr['NAXIS'] = 2
                            hdr['NAXIS1'] = imgsz[0]
                            hdr['NAXIS2'] = imgsz[0]
                            hdr['CTYPE1'] = 'RA---TAN'
                            hdr['CTYPE2'] = 'DEC--TAN'
                            hdr['CRVAL1'] = onegal['RA']
                            hdr['CRVAL2'] = onegal['DEC']
                            hdr['CRPIX1'] = imgsz[0]/2+0.5
                            hdr['CRPIX2'] = imgsz[0]/2+0.5
                            hdr['CD1_1'] = -pixscale/3600
                            hdr['CD1_2'] = 0.0
                            hdr['CD2_1'] = 0.0
                            hdr['CD2_2'] = +pixscale/3600
                            wcs = WCS(hdr)
                    
                            try:
                                draw_ellipse_on_png(colorimg, imgsz[0]/2, 0.5*imgsz[1], onegal['BA'], 
                                                    onegal['PA'], 2*onegal['R1']*60, 
                                                    pixscale, color='red', linewidth=2)
                            except:
                                pdb.set_trace()

                            # add the SGA sources, if any
                            if len(onesga) > 0:
                                for onesga1 in onesga:
                                    xpos, ypos = wcs.wcs_world2pix(onesga1['RA'], onesga1['DEC'], 1)
                                    draw_ellipse_on_png(colorimg, xpos, imgsz[1]-ypos, onesga1['BA'], 
                                                        onesga1['PA'], onesga1['D26'] * 60.0, pixscale, 
                                                        color='dodgerblue', linewidth=2)
            
                            print(f'Writing {pngfile1}')
                            colorimg.save(pngfile1)
            
                        label = onegal['OBJNAME']
                        addbar_to_png(pngfile1, barlen, barlabel, label, pngfile1, scaledfont=True)
                        #pdb.set_trace()
            
                    pngfiles.append(pngfile1)
            
                pngfile = os.path.join(paperdir, 'data', 'hecate', 'hecate-notin-sga-{}-{:02d}.png'.format(binlabel, ipage))
                print('Writing {}'.format(pngfile))
            
                cmd = 'montage -bordercolor white -borderwidth 1 -tile {}x{} -geometry 512x512 '.format(ncol, nrow)
                cmd = cmd+' '.join([pngf for pngf in pngfiles])
                cmd = cmd+' {}'.format(pngfile)
                print(cmd)
                os.system(cmd)        
    
                #pdb.set_trace()
    # --------------------------------------------------

    # make the QA -
    @ticker.FuncFormatter
    def major_formatter(x, pos):
        if x >= 0:
            return '{:.0f}'.format(10**x)
        elif (x < 0) and (x >= -1):
            return '{:.1f}'.format(10**x)
        else:
            return '{:.2f}'.format(10**x)

    fig, ax = plt.subplots(figsize=(10, 7))

    xlim = (minrad, maxrad)
    ylim = (6.5, 26)
    I = np.isfinite(hecate['BT'])
    corner.hist2d(np.log10(2*hecate['R1'][I]), hecate['BT'][I],
                  levels=[0.1, 0.25, 0.5, 0.75, 0.95, 0.99],
                  #levels=[0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99],
                  bins=75, smooth=True, ax=ax, color='k', #mpl.cm.get_cmap('viridis'),
                  plot_density=True, fill_contours=True, range=(xlim, ylim),
                  data_kwargs={'color': 'k', 'alpha': 1.0, 'ms': 3, 'alpha': 0.5},
                  contour_kwargs={'colors': 'k', 'alpha': 0.5}
                 )
    ax.set_xlabel(r'$\log_{10}\,(5\times r_{50,\mathrm{ElPetro}})$ [HECATE, arcmin]')
    ax.set_ylabel(r'$m_{r,\mathrm{ElPetro}}$ [HECATE]')
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.yaxis.set_major_locator(ticker.MultipleLocator(2))
    ax.xaxis.set_major_formatter(major_formatter)
    ax.set_xticks(np.log10([0.05, 0.2, 0.5, 1, 2, 5, 10, 19]))
    
    ax2 = ax.twinx()
    #for bb in bins:
    #    ax2.axvline(x=bb, color='orange', ls='-', alpha=1)
    ax2.axvline(x=np.log10(20/60), color=colors[2], ls='--', alpha=1)
    #ax2.axvline(x=np.log10(30/60), color=colors[0], ls='--', alpha=1)
    ax2.axhline(y=1.0, ls='--', lw=2, color=colors[2], alpha=1)
    ax2.step(xfrac+drad, yfrac, color=colors[3], ls='-', lw=3, where='pre')
    ax2.set_ylim(0, 1.05)
    ax2.set_ylabel('Fraction of SGA-HECATE Matches')

    if png:
        pngfile = os.path.join(figdir, png)
        print('Writing {}'.format(pngfile))
        fig.subplots_adjust(bottom=0.14, right=0.85)
        fig.savefig(pngfile)#, bbox_inches='tight')
        plt.close(fig)

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--sample-montage', action='store_true')
    parser.add_argument('--hyperleda-rejects', action='store_true')
    parser.add_argument('--sky', action='store_true')
    parser.add_argument('--size-mag', action='store_true')
    parser.add_argument('--sga-properties', action='store_true')
    parser.add_argument('--redshifts', action='store_true')
    parser.add_argument('--coordinates', action='store_true')
    parser.add_argument('--sga-vs-hyperleda', action='store_true')
    parser.add_argument('--sga-vs-wxsc100', action='store_true')
    parser.add_argument('--table-dwarfs', action='store_true')
    #parser.add_argument('--rich-groups', action='store_true')
    parser.add_argument('--nsa-completeness', action='store_true')
    parser.add_argument('--hecate-completeness', action='store_true')
    #parser.add_argument('--sb-mag', action='store_true')
    parser.add_argument('--sbmontage', action='store_true')
    #parser.add_argument('--sbmontage-gallery', action='store_true')
    args = parser.parse_args()

    #if False:
    #    galaxy, galaxydir = get_galaxy_galaxydir(sample)
    #    for onegal in sample:
    #        _galaxy, _ = get_galaxy_galaxydir(onegal)
    #        print(_galaxy, onegal[RACOLUMN], onegal[DECCOLUMN], onegal[DIAMCOLUMN])

    sga = legacyhalos.SGA.read_sga2020(ext='ELLIPSE')

    # Table
    if args.table_dwarfs:
        table_dwarfs(tex='mwdwarfs.tex')
            
    # Fig 1 - sample montage
    if args.sample_montage:
        #tractor = legacyhalos.SGA.read_sga2020(ext='TRACTOR')
        fig_sample_montage(sga, seed=1, png='sample-montage.png')
        
    # Fig 2 - Hyperleda junk rejected by visual inspection
    if args.hyperleda_rejects:
        fig_hyperleda_rejects(sga, png='hyperleda-rejects.png')
        
    # Figs 3 & X - spatial distribution on the sky
    if args.sky:
        fig_sky(sga, png='sga-2020-sky.png')
        parent = legacyhalos.SGA.read_sample(preselect_sample=False)
        #parent = fits_table(os.path.join(legacyhalos.io.legacyhalos_dir(), 'sample', 'v3.0', 'SGA-parent-v3.0.fits'))
        fig_sky(parent, png='sga-2020-parent-sky.png')
        
    # Fig X - bivariate scatterplot of size vs magnitude
    if args.size_mag:
        fig_size_mag(sga, png='parent-size-mag.png', leda=True)

    # Fig X - 
    if args.sga_properties:
        fig_sga_properties(sga, png='sga-properties.png')

    if args.redshifts:
        fig_redshifts(sga, png='redshifts.png')

    if args.coordinates:
        fig_coordinates(sga, png='coordinates.png')

    if args.sga_vs_hyperleda:
        fig_sga_vs_hyperleda(sga, png='sga-vs-hyperleda.png')

    if args.sga_vs_wxsc100:
        fig_sga_vs_wxsc100(sga, png='sga-vs-wxsc100.png')

    # Fig - completeness against the NSA
    if args.nsa_completeness:
        fig_nsa_completeness(sga, png='nsa-completeness.png')
    
    # Fig - completeness against HECATE
    if args.hecate_completeness:
        fig_hecate_completeness(sga, png='hecate-completeness.png')

    ## Fig X - richest groups
    #if args.rich_groups:
    #    fig_rich_groups(sga, png='rich-groups.png')

    # Fig - SB montages
    if args.sbmontage:
        sample = legacyhalos.SGA.read_sga2020(galaxylist='NGC5016')
        fig_sbmontage(sample, igal=0, colorlim=(-0.5, 1.5), png='NGC5016-sbmontage.png')

        sample = legacyhalos.SGA.read_sga2020(galaxylist='PGC193192')#, primary=False)
        fig_sbmontage(sample, igal=1, colorlim=(0.0, 1.5), png='PGC193199-sbmontage.png')

        #for gal in galaxy:
        #    fig_surface_brightness(sample, thisgalaxy=gal, png='surface_brightness_{}.png'.format(gal))
        #fig_surface_brightness(sample, thisgalaxy='0000195-052316929', png='surface_brightness.png')
        #fig_surface_brightness(sample, thisgalaxy='0001129-034040952', png='surface_brightness.png')

    ## Fig - SB montage gallery
    #if args.sbmontage_gallery:
    #    if False:
    #        from astrometry.libkd.spherematch import match_radec
    #        saga = Table.read(os.path.join(os.getenv('HOME'), 'research', 'projects', 'SGA', 'sample', 'catalogs', 'saga_hosts.csv'))
    #        m1, m2, d12 = match_radec(sample['RA'], sample['DEC'], saga['RA'], saga['DEC'], 5/3600.0, nearest=True)
    #        out = sample[m1]
    #        out.write(os.path.join(figdir, 'saga.fits'), overwrite=True)
    #    else:
    #        #if False:
    #        sample = Table.read(os.path.join(figdir, 'saga.fits'))
    #        for onegal in sample[:45]:
    #            fig_sbmontage_gallery(onegal, png='gallery/sbmontage-{}.png'.format(onegal['GALAXY']))
    #        #else:

    ## Fig - bivariate scatterplot of surface brightness vs magnitude
    #if args.sb_mag:
    #    parent = legacyhalos.SGA.read_sample(preselect_sample=False)
    #    fig_sb_mag(sga, parent, png='sga-sb-mag.png')
    
if __name__ == '__main__':
    main()
